iApp【指定系统编译】

[方案一]

// 在裕语言V5中可以指定系统来编译代码

//执行 java 多行代码
java
{
  String str = "这是 iApp";
  android.util.Log.v("iapp", str);

}

//执行 java 单行代码
java android.util.Log.v("iapp", "这是 iApp");


[方案二]

// 裕语言V5 允许java 格式文件，进行混编交互。

// 创建 *.java 文件 并且完全支持 android 原生开发。


【目录开头符号标识】

// 代码中需要输入一个文件的代码，填写路径的开头第一个可以使用符号进行快捷指向路径

// 路径开头为 % 硬盘分区根路径

// 路径开头为 @ 包内资源路径

// 路径开头为 $ 应用安装位置路径


【裕语言v5 里的根对象】

用法：

//这是裕语言V5里的根对象，也是所有子对象的父对象，裕语言V5 所有代码的源头命名。
iapp


//------- 根对象的 子对象

// 字符管理对象
iapp.zf

// 数据管理对象
iapp.sj

// 视图管理对象
iapp.st

// 文件管理对象
iapp.wj

// 工具管理对象
iapp.gj

// 网络管理对象
iapp.wl

// 系统管理对象
iapp.xt

//前缀 iapp 是根对象的，也可以直接写它的子对象

如：
// 工具对象 里的 输出方法
gj.sc("输出文字")


//------- 根对象的 方法

// 为了更简便的使用常用方法，根对象提供以下方法：

// 输出
iapp.gj.sc(123) 可直接使用 gj.sc(123)

【资源管理对象】
// 资源管理对象，与代码根对象不同，主要的作用是获取项目内相关资源的ID
// 资源管理对象的 根对象
zy 或 iapp.zy


// 获取 strings.xml 内的名称为 a 字符串
s a = zf.zf(zy.z.a)

// 获取 drawable 内的文件名为 b.xml 的文件，常用于背景的绘制
s b = sj.hz(zy.h.b)

// 获取 mipmap 内的文件名为 c.png 的图像资源ID（一个整数），可将ID设置给图像控件、图像按钮控件等
s c = zy.t.c

// 获取控件的ID
s d = zy.id.wb1
//或
//s d = zy.i.wb1


【类模块对象的创建】

// myu 类模块需要先创建对象
cj 或  iapp.cj

// 创建 abc.myu 类模块的对象，同时会调用 abc.myu 类模块的构造 ff lei()
s abc = cj.abc()

// 调用类模块的变量
s b = abc.b

// 调用类模块的方法
s c = abc.c()


// 也可以用于数组对象的创建，创建一个长度为 10 的字符串数组
string[] sz = cj.string[10]


【修饰符】

// 全局；在变量或 方法前加上后可使用 文件名.方法或变量名 进行访问。
qj

// 私有；在变量或 方法前加上后，方法或变量名仅供当前文件访问。
sy

// 固定；申明 变量 并赋值后，其值不可改变。其变量可在方法内任意代码块里调用，如下
gd

// gd 例1
ff a()
{

gd s abc = "abc"

// 创建线程
gj.xc(){

gj.sc(abc)

}

}

【自定义application】
在 AndroidManifest.xml 中自定义 application name 类一定要 extends i.app.applicationMain

【s 数据类型】

用法：

// 推断类型

//说明：根据首次赋值的数据来推断变量类型。推断类型 无法作为方法的申明参数变量使用。


// 字符串型（String）
s d = "nihao"
string d2 = "nihao"


// 整数型（int）
s e = 123
int e2 = 123


// 小数型（double）
s f = 123.123
double f2 = 123.123


// 是否型（boolean）
s g = shi
boolean g2 = fou
//可以这写
//s g = true
//boolean g2 = false


// 数据型（Object）
s h = kong
object h = null

//可以这写，不赋值。注意：变量默认值不为 kong 
//s h
//object h


// 方法参数变量需要指向性数据类型

方法，例：

ff jyg(s bl = 0)
{
fh bl + 1
}

// 全局变量：需要写在类模块里，并且不能写在方法内，应该写在方法外；

// 1. 在 类模块 里申明的变量；可以在该类中的所有方法 或 事件方法 内使用；
s abc = 1

// 增加全局修饰符
qj s abc2 = 2

【myu 类模块】
// 创建一个 abc.myu 源码文件，内容如下：

// 创建 模块变量 a并赋值
s a = "NiHao"
s aa = ""
qj s aaa = "全局变量"

// 用java申明变量
java int abc1 = 100

java public int abc5 = 200

// 用java写方法
java
{
  public void abc2(int abc22)
  {
    abc1 = abc22;
  }

  public int abc3(int abc33)
  {
    return abc1 + abc33 + 100;
  }
}

// 构造方法
ff lei(s a = "")
{
aa = a
}

// 创建方法 b
ff s b()
{
  fh a
}

// 创建方法 c
ff s c(s d = "")
{
  fh a + d + aa
}

// ----- 调用实例 -----

// 创建对象
s abc = cj.abc("hahaha")

// 输出 模块变量 aa
gj.sc(abc.aa)

// 输出 模块方法 b
gj.sc(abc.b())

// 输出 模块方法 c
gj.sc(abc.c("Ma?"))

// 输出 全局变量
gj.sc(abc.aaa)

// 调用java写的方法
java abc.abc2(123)

// 调用java写的方法
java gj.sc(abc.abc3(567))

// 获取java申明的变量
java gj.sc(abc.abc5)

【ff 方法】

// 以 ff 开头 + [可选：修饰符] + [可选：方法返回类型] + 方法名 ( 参数 [可选：强制参数类型] )
ff abc()
{
  gj.sc("这是 无返回数据，无参数 的方法")
}


// fh 为 返回数据的代码

// 返回如设置 s 将等同于Object类型
ff s abc(s a)
{
  gj.sc("这是 返回数据a + 123，参数变量a将等同于Object类型 的方法")
  fh a + 123
}

// 返回如设置 int 为整数类型
ff int abc(s a = 0)
{
  gj.sc("这是 返回数据a + 123，参数变量a预设值为整数0将 s 类型强制转换为 int 的方法")
  fh a + 123
}


// 修饰符 qj 为全局方法，其他界面 与 模块 里可以调用
// 返回如设置 int 为整数类型
qj ff int abc(int a)
{
  gj.sc("这是 返回数据a + 123，参数变量a类型为 int 的方法")
  fh a + 123
}


【数组类型】
用法：

// 申明一个字符串数组
s sz1 = { "abc", "def", "g" }
// 申明一个字符串数组
string[] sz4 = { "abc", "def", "g" }

// 获取数组长度
s cd = sz1.length

// 申明一个字符串数组
s sz2 = cj.string[3]
// 给数组赋值
sz2[0] = "abc"
sz2[1] = "def"
sz2[2] = "g"

// 读取数组内容
s a1 = sz2[0]

// 申明一个类模块数组，提前创建一个类模块 mk.myu
// 初始化模块
s mk1 = cj.mk()
s mk2 = cj.mk()
// 创建类模块数组
s sz3 = { mk1, mk2 }

// 创建类模块数组
s sz5 = cj.mk[2]
sz5[0] = mk1
sz5[1] = mk2

// 循环数组
xh s q1, sz1
{
gj.sc(q1)
}

xh s q2, sz5
{
gj.sc(q2)
}


【数组列表类型】
用法：

// 申明一个字符串的数组列表
alist<string> lb1 = cj.alist<string>()

// 申明一个类模块的数组列表，提前创建一个类模块 mk.myu
alist<mk> lb2 = cj.alist<mk>()

// 添加数据
s q2 = "abc";
lb1.add(q2)
// 指定序号位置添加数据， 序号是从0开始
lb1.add(0, "bc")

// 指定序号位置修改数据
lb1.set(0, "bcbc")

// 获取数组列表长度
s cd = lb1.size()

// 获取数据
s q1 = lb1.get(0)

// 获取是否存在数据
s cz = lb1.contains(q2)

// 获取数据在列表中的序号，从开始位置向后查找，序号是从0开始
s x1 = lb1.indexOf(q2)

// 获取数据在列表中的序号，从结束位置向前查找，序号是从0开始
s x2 = lb1.lastIndexOf(q2)

// 删除数据
lb1.remove(0)
// 删除数据 或输入数据对象
lb1.remove(q2)
// 删除所有数据
lb1.clear()

// 循环数组列表
xh s q3, lb1
{
gj.sc(q3)
}


【哈希表类型】
用法：

// 申明一个字符串的数组列表
hmap<string, string> map1 = cj.hmap<string, string>()

// 申明一个类模块的数组列表，提前创建一个类模块 mk.myu
hmap<string, mk> map2 = cj.hmap<string, mk>()

// 添加数据
s q2 = "abc";
// 指定 键名 添加或修改 数据
map1.put("a", "bcc")
map1.put("b", q2)

// 获取哈希表长度
s cd = map1.size()

// 指定 键名 获取数据
s q1 = map1.get("a")

// 获取指定 键名 是否存在
s cz = map1.containsKey("a")

// 获取指定 数据对象 是否存在
s cz2 = map1.containsValue(q2)

// 指定 键名 删除数据
map1.remove("a")

// 指定 键名 和 键值 删除数据，需要 键名 和 键值 匹配后删除
map1.remove("b", q2)

// 删除所有数据
map1.clear()

// 循环 键名
s sz2 = map1.keySet()
xh s x2, sz2
{
  gj.sc(x2)
}

// 循环 键值
s sz = map1.values()
xh s x1, sz
{
  gj.sc(x1)
}

【// 或 /* */ 注释】

用法：

//单行注释

/*
这是多行注释
*/


【gj.sc 输出】
用法：

// 可以输出数据
gj.sc("1314")

【rg 如果判断】
用法：

s a = 2
rg a == 1
{
	gj.sc("等于1")
}
,a == 2
{
	gj.sc("等于2")
}
,
{
	gj.sc("等于其他")
}

支持运算符（返回 是 与 否）：
== 是否对等
!= 是否不等于
>= 是否大于或等于
<= 是否小于或等于
> 是否大于
< 是否小于
?* 字符串开头是否相同
*? 字符串结尾是否相同
? 字符串是否被包含
上面三个举例：
s a = "abcdef"
rg a ?* "abc" 返回“是”
rg a *? "def" 返回“是”
rg a ? "cde" 返回“是”

支持逻辑运算符：
|| 或者
&& 并且


【xh 循环】
用法：
//这将循环99次
s a = 99
// 单个表达式循环
xh a > 0
{
gj.sc(a)
a = a - 1
}

//这将循环9次，使用 a-- 让变量每次减少1
s a = 9
// 单个表达式循环
xh a > 0
{
gj.sc(a)
a--
}

//这将循环9次，使用 a++ 让变量每次增加1
s a = 0
// 单个表达式循环
xh a < 9
{
gj.sc(a)
a++
}

// 循环扩展2
s sz = { "a", "b", "c", "d" }
// 2个表达式的循环
xh s i, sz
{
gj.sc(i)
}


// 循环扩展3
s a = 9
// 3个表达式的循环
xh s i=0, i<a, i++
{
gj.sc(i)
}

// tcxh 将直接跳出循环
s a = 9
// 3个表达式的循环
xh s i=0, i<a, i++
{
  rg i>3{
    tcxh
  }
gj.sc(i)
}

// tcbcxh 将直接跳出本次循环，并继续执行后面的循环
s a = 9
// 3个表达式的循环
xh s i=0, i<a, i++
{
  rg i>3{
    tcbcxh
  }
gj.sc(i)
}

说明：
条件循环语句，比较值的变化，然后进行循环执行 { 代码 } 里面的代码。当条件为“否”的时候会停止循环，条件“是”的话，将一直循环执行。
支持运算符（返回 是 与 否）：（跟 rg 语句 一样，请参考）

【yc 异常】

// 无异常日志
yc{
gj.sc("执行正常代码")

},{

gj.sc("如果发生异常，将被执行")

}

// 有异常日志
yc{
gj.sc("被执行代码")

},(e){

gj.sc("如果被执行代码发生异常，将被执行；异常日志:" + e)

}

说明：
常用于可能发生异常代码的执行，其中的代码如果发生了异常不会造成应用崩溃。

【st.*() 获取视图控件】
用法：

//如，获取文本控件对象
// 输入控件的ID
s wb = st.wb(zy.id.wb1)
gj.sc(wb)


s wb2 = st.wb(zy.id.wb2)
// 获取控件的原对象 返回 TextView类型
gj.sc(wb2.st)

// 获取文本控件的文本字符
gj.sc(wb2.zf())


// 设置文本控件的文本字符
wb2.zf("ni hao ma?")

// 其他所有控件获取方法是一样的，获取的对象 子方法可能有差别。

// 获取线性布局对象
// 输入控件的ID
s xxbj = st.xxbj(zy.id.xxbj1)
gj.sc(xxbj)


// 获取视图对象，获取的是View对象
// 获取wb1视图对象
s wb1 = st.st(zy.id.wb1)

// 根据 xxbj1对象来获取其中的 wb2 的视图对象
s xxbj1 = st.st(zy.id.xxbj1)
s wb2 = st.st(xxbj1, zy.id.wb2)


【gj.xc 新线程】
用法：
gj.xc()
{
	gj.sc("新线程里执行代码")
}

说明：
启用新线程，去执行一些需要执行很久的代码。比如把下载文件，获取网页源码，大量的文件操作，可以放入新线里执行。这里线程的概念，启用新的线程帮你处理代码，这样不会影响到主线程。


【gj.jmxc 界面线程上运行】
用法：
// 对应V3.0 线程更新界面

gj.jmxc()
{
	gj.sc("界面线程上运行代码")
}



// 界面线程 上对视图进行操作

// 启用一个新线程
gj.xc()
{
// 这里可以执行耗时间的数据处理

// 然后需要更新视图控件时，需要在界面线程上面执行，否则将报错
gj.jmxc()
{
  s wb2 = st.wb(zy.id.wb2)
  // 设置文本控件的文本字符
  wb2.zf("ni hao ma?")
}

}


说明：
在启用新线程去执行代码时，是不允许直接对视图进行更新。视图控件需要在界面线程上更新，否则将报错；


【gj.ts 提示】
用法：

// 该方法需要手机开放应用的通知权限

// 第一个参数为 需要被提示的内容
gj.ts("你好")

// 或 第二个参数为显示时长 1代表正常，2代表短暂
gj.ts("你好", 1)


【wj.wj 获得文件对象】
用法：
// 获取文件对象
s f = wj.wj("%a.txt")
// 输出完整文件路径
gj.sc(f.getAbsolutePath())


【wj.cz 文件是否存在】
用法：
// 文件是否存在
s a = "%abc.zip"
s b = wj.cz(a)

// 文件夹是否存在
s a = "%abc"
s b = wj.cz(a)

//返回 true 或 false
gj.sc(b)

【wj.sc 删除文件】
用法：
// 删除文件
s a = "%abc.zip"
s b = wj.sc(a)

// 文件夹删除，并删除子文件夹
s a = "%abc"
s b = wj.sc(a, true)

//返回 删除文件的数量
gj.sc(b)

【wj.dx 文件大小】
用法：
s a = "%abc.zip"
s b = wj.dx(a)

//返回 文件 或 文件夹 的大小
gj.sc(b)

【wj.dqwb 读取文本】
用法：(将读取SD卡根目录的abc.txt文件里面的内容)
s a = "%abc.txt"
s c = wj.dqwb(a)

s a = "%abc.txt"
s b = "utf-8"
s c = wj.dqwb(a, b)

//返回 文本文件 的内容
gj.sc(b)

【wj.xrwb 写入文本】
用法：(将文本数据写入至SD卡根目录的abc.txt文件里面)
s a = "%abc.txt"
s b = "我是一个txt文件的内容"
s d = wj.xrwb(a, b)

s a = "%abc.txt"
s b = "我是一个txt文件的内容"
s c = "utf-8"
s d = wj.xrwb(a, b, c)

//返回 true 或 false
gj.sc(d)


【wj.fz 复制文件】
用法：
s a = "%abc.txt"
s b = "%abc2.txt"
s d = wj.fz(a, b)

//设置重复不覆盖
s c = false
s d = wj.fz(a, b, c)

//返回 true 或 false
gj.sc(d)


【wj.lb 文件夹与文件列表】
用法：

// 注意 lb l是字母L的小写， 为拼音首字母 lb=列表

s a = "%dir"

//获取文件夹与文件列表
s b = wj.lb(a)
// 循环数组
xh s c, b
{
  gj.sc(c)
}

//仅获取文件夹列表
s a = "%dir"
s b = wj.lb(a, true)
// 循环数组
xh s c, b
{
  gj.sc(c)
}

//仅获取文件列表
s a = "%dir"
s b = wj.lb(a, false)
// 循环数组
xh s c, b
{
  gj.sc(c)
}


【wj.czwj 查找文件】
用法：

// 文件名过滤，开头与结尾的*为任意字符
s gl = { "*.txt", "abc", "abc*" }

// 获取一个 File[] 对象数组
s lb = wj.czwj("%dir", gl)

// 循环打印
xh s c, lb
{
  gj.sc(c.getAbsolutePath())
}


【wj.zy 转移文件】
用法：
s a = "%abc.txt"
s b = "%abc2.txt"
s d = wj.zy(a, b)

//设置重复不覆盖
s c = false
s d = wj.zy(a, b, c)

//返回 true 或 false
gj.sc(d)


【wj.hqml 获取目录路径】
用法：

s a = "%dir"
s d = wj.hqml(a)

//返回 绝对路径
gj.sc(d)

【wj.jy 解压zip文件】
用法：

// 目标ZIP
s a = "%a.zip"
// 只解压部分文件
s b = "b.txt"
// 解压到指定目录
s c = "%dir"
// 重复是否覆盖
s d = true

// 解压指定部分文件文件，并指定重复覆盖
s e = wj.jy(a, b, c, d)

//返回 解压文件数量
gj.sc(e)

// 解压文件，并指定重复覆盖
s e = wj.jy(a, c, d)
//返回 解压文件数量
gj.sc(e)

// 解压文件，重复不覆盖
s e = wj.jy(a, c)
//返回 解压文件数量
gj.sc(e)


【wj.ys 压缩zip文件】
用法：

// 目标文件夹路径
s a = "%dir"

// 压缩到ZIP的路径
s b = "%a.zip"

// 解压文件，重复不覆盖
s d = wj.ys(a, b)

//返回 压缩的文件数量
gj.sc(d)


【wj.dk 打开文件】
用法：
s a = "%abc.apk"
wj.dk(a)

//无返回

【wj.lx 文件类型】
用法：
s a = "%abc"
s b = wj.lx(a)

//返回一个整数，1为文件  2为文件夹  -1为不存在


【zf.th 替换字符】
用法：

s a = "123456789"
s b = "2"
s c = "0"
s d = zf.th(a, b, c)

//返回 替换后的字符
gj.sc(d)

//支持正则表达式
s d = zf.th(a, b, c, true)

【zf.qc 取出字符】
用法：

s a = "123456789"
s b = "23"
s c = "78"
s d = zf.qc(a, b, c)

//返回 取出后的字符
gj.sc(d)

s b = 2
s c = 6
s d = zf.qc(a, b, c)

//返回 取出后的字符
gj.sc(d)


【zf.fg 分割字符】
用法：

s a = "12,34,56,789"
s b = ","
s d = zf.fg(a, b)

// 循环数组
xh s e, d
{
  gj.sc(e)
}

// 支持正则表达式
s d2 = zf.fg(a, b, true)

【zf.cx 从头查询字符位置】
用法：

s a = "123456789"
s b = "56"
s d = zf.cx(a, b)

//返回 查询的字符位置
gj.sc(d)

// 设置查询的起始位置，从位置 2 开始查询
s c = 2
s d = zf.cx(a, b, c)

//返回 查询的字符位置
gj.sc(d)


【zf.dc 从尾倒查询字符位置】
用法：

s a = "123456789"
s b = "56"
s d = zf.dc(a, b)

//返回 查询的字符位置
gj.sc(d)

// 设置查询的起始位置，从位置 2 开始查询
s c = 2
s d = zf.dc(a, b, c)

//返回 查询的字符位置
gj.sc(d)


【zf.cd 获取字符长度】
用法：

s a = "123456789"
s d = zf.cd(a)

//返回 字符的长度
gj.sc(d)

【zf.qctwkg 去除头尾空格】
用法：

s a = "  123456789 "
s d = zf.qctwkg(a)

//返回 字符的将去除头尾空格
gj.sc(d)


【zf.zhxx 转换为小写】
用法：

s a = "aBcDefGh"
s d = zf.zhxx(a)

//返回 字符的将转换为小写
gj.sc(d)


【zf.zhdx 转换为大写】
用法：

s a = "aBcDefGh"
s d = zf.zhdx(a)

//返回 字符的将转换为大写
gj.sc(d)


【zf.sjs 生产范围随机数】
用法：

s a = 1000
s b = 9999
s d = zf.sjs(a, b)

gj.sc(d)


【gj.zt 暂停代码】
// 创建线程
gj.xc(){

// gj.zt(以毫秒为单位，1秒=1000毫秒)
gj.zt(1000)
gj.sc("1秒后")

gj.zt(3000)
gj.sc("3秒后")

}

【数组】
用法：
s sz = { "a", "b", "c", "d" }
s sz2 = { 1, 2, 3, 4 }
s sz3 = cj.string[5]

// 循环数组
xh s e, sz
{
  gj.sc(e)
}

// 访问指定维度
s a = sz[0]
gj.sc(a)

// 获取数据长度
s d = sz.length
gj.sc(d)


【wl.hq 获取网页源码】
用法：

// 需要注意的是 wl.hq 需要放入线程中执行；

// 创建线程
gj.xc(){

// 网址
s a = "https://m.baidu.com"

// post提交的数据，对应name1=value1&name2=value2，这个参数可以设置 null 则为 get方式
s b = { "name1=value1", "name2=value2" }

// 编码
s c = "utf-8"

// 传递cookie项值，格式为nama=value 下例： uid=112;name=nihao;sb=123456789;
s d = "uid=112;name=nihao;sb=123456789;"

// 带自动设置cookie方式获取网页，并记录当前网页的Cookie
s e = true

// 设置Header头:（可设置多条，以“||”隔开）文件头包括了Cookie，User-Agent设备型号
s f = "User-Agent=Mozilla/5.0 (iPad; U; CPU OS 6_0 like Mac OS X; zh-CN; iPad2)||accept=*/*||accept-language=zh-CN"

// get方式：网址，编码
s st2 = wl.hq(a, c)

// post方式：网址，数据，编码
s st3 = wl.hq(a, b, c)

// post方式：网址，数据，编码，传递cookie
s st4 = wl.hq(a, b, c, d)

// post方式：网址，数据，编码，传递cookie, 是否自动设置cookie，设置Header头，设置连接超时，设置接收超时
s st5 = wl.hq(a, b, c, d, e, f, 20000, 20000, null)

// post方式：网址，数据，编码，传递cookie, 是否自动设置cookie，设置Header头，设置连接超时，设置接收超时，设置代理IP（若不设置就传入null）
s st5 = wl.hq(a, b, c, d, e, f, 20000, 20000, "10.0.0.172:80")

//返回 网页源码
gj.sc(st2)

}


【wl.hqjson 获取源码并且提交json内容】
用法：

// 需要注意的是 wl.hqjson 需要放入线程中执行；

// 创建线程
gj.xc(){

// 网址
s a = "https://m.baidu.com"

// post提交的数据，对应json内容，这个参数可以设置 null 则为 get方式
s b = "{\"id\":1, \"name\":\"xiaobai\", \"age\":16}"

// 编码
s c = "utf-8"

// 传递cookie项值，格式为nama=value 下例： uid=112;name=nihao;sb=123456789;
s d = "uid=112;name=nihao;sb=123456789;"

// 带自动设置cookie方式获取网页，并记录当前网页的Cookie
s e = true

// 设置Header头:（可设置多条，以“||”隔开）文件头包括了Cookie，User-Agent设备型号
s f = "User-Agent=Mozilla/5.0 (iPad; U; CPU OS 6_0 like Mac OS X; zh-CN; iPad2)||accept=*/*||accept-language=zh-CN"

// post方式：网址，数据，编码
s st3 = wl.hqjson(a, b, c)

// post方式：网址，数据，编码，传递cookie
s st4 = wl.hqjson(a, b, c, d)

// post方式：网址，数据，编码，传递cookie, 是否自动设置cookie，设置Header头
s st5 = wl.hqjson(a, b, c, d, e, f)

// post方式：网址，数据，编码，传递cookie, 是否自动设置cookie，设置Header头，设置连接超时，设置接收超时，设置代理IP
s st5 = wl.hqjson(a, b, c, d, e, f, 20000, 20000, "10.0.0.172:80")

//返回 网页源码
gj.sc(st2)

}


【wl.xz 下载文件】
用法：

// 创建线程
gj.xc(){

s a = "https://m.baidu.com/static/index/plus/plus_logo.png"
s b = "%plus_logo.png"
s d = wl.xz(a, b)

//返回 下载状态码，0为下载成功，1为下载已重复，-1为下载失败
gj.sc(d)

}

【wl.fw 访问网页】
用法：
s a = "https://m.baidu.com"
wl.fw(a)


【gj.tz 跳转界面】
用法：
// 跳转 abc.iyu 界面
gj.tz("abc")

// 或
gj.tz(abc.lei)


//或 根据包名+类名 跳转 com.iapp.abc 界面，访问 com.iapp 包的 abc.iyu 界面
gj.tz("com.iapp.abc")


// 跳转 abc 界面，并携带数据，数据为2个数组；要求相互对应 name : value 数据是对应的，包括长度也需要一样（如它们同样都是3个）；
s name = { "name1", "name2", "name3" }
s value = { "value1", "value2", "value3" }
gj.tz("abc", name, value)


Bundle bundle = 自定义一个 Bundle
gj.tz("abc", bundle)


【sj.hqtz 获取跳转的数据】
用法：
// 当跳转界面后，可以再跳转后的界面进行获取相关数据

// 根据 name 来获取它的值
s name1 = sj.hqtz("name1")
gj.sc(name1)


// 直接获取 Bundle
s bundle = sj.hqtz()
gj.sc(bundle)


【st.tc 弹窗界面】
用法：
s tb = zy.t.i
s bt = "标题"
s nr = "内容"
s an1 = "按钮1"
s an2 = "按钮2"
s an3 = "按钮3"


// 无按钮
s tc1 = st.tc(bt, nr)

// 有图标 无按钮
s tc2 = st.tc(tb, bt, nr)

// 有图标 1个按钮
s tc2 = st.tc(tb, bt, nr, an1){

gj.sc("按钮1")

}


// 有图标 2个按钮
s tc2 = st.tc(tb, bt, nr, an1, an2){

gj.sc("按钮1")

}, {

gj.sc("按钮2")

}

// 有图标 3个按钮
s tc2 = st.tc(tb, bt, nr, an1, an2, an3){

gj.sc("按钮1")

}, {

gj.sc("按钮2")

}, {

gj.sc("按钮3")

}

// 变量 nr 可输入布局视图
// 弹窗返回对象类型 AlertDialog , 可调用方法关闭弹窗

// 关闭指定的弹窗
tc2.dismiss()


【gj.gb 关闭界面】
用法：

// 关闭当前界面
gj.gb()


【gj.xszm 显示桌面】
用法：

// 显示桌面
gj.xszm()


【gj.mtbf 媒体播放】
用法：

// 输入媒体数据源
// 本地媒体，支持格式 3gp,mp3,mp4,mkv,wav,ogg,ts,aac
s mt = gj.mtbf("%abc.mp3")

// 网络媒体，支持协议 http / https / rtsp
s mt2 = gj.mtbf("http://www.abc.com/abc.mp3")


// raw资源 输入资源文件的ID
s mt2 = gj.mtbf(zy.raw.mp3)

// 带回调的方法
s mt = gj.mtbf("%abc.mp3"){
// 播放结束后调用

}

// 开始播放
mt.ks()

// 暂停
mt.zt()

// 停止
mt.tz()

// 释放资源
mt.sf()

// 当前播放状态，返回整数型 1正在播放，0没有播放，-1获取失败
s bfzt = mt.bfzt()

// 获取媒体的时长（毫秒）
s mtsc = mt.mtsc()

// 获取当前播放位置（毫秒）
s bfwz = mt.bfwz()

// 重播
mt.cb()

// 指定播放的位置（毫秒）
// 1分钟后
s tz = 60000
mt.zdbfwz(tz)

// 播放器的音量（0-100），左声道与右声道
mt.bfyl(100, 100)

// 设置是否循环播放
mt.xhbf(true)

// 设置播放完毕后自动释放资源
mt.zdsf()

【gj.ftz 发送通知】
用法：
s tsbt = "提示标题"
s bt = "标题"
s test = "内容"
s icon = zy.t.i
// 点击通知后跳转到 abc.iyu 界面
s iyu = abc.lei

// 无附带参数
gj.ftz(tsbt, bt, test, icon, iyu)

// 布局
s layout = null

// 附带参数
s name = { "name1", "name2", "name3" }
s value = { "value1", "value2", "value3" }
gj.ftz(tsbt, bt, test, icon, layout, iyu, name, value)

// 注意，需要给予应用通知权限，否则无效

【st.xfc 悬浮窗】
用法：
s v = 视图控件
s k = 200
s g = 200
s x = 100
s y = 100

// 创建并显示悬浮窗
s xfc = st.xfc(v, k, g, x, y)

// 设置视图显示位置
xfc.xy(x, y)

// 设置视图大小
xfc.kg(k, g)

// 设置是否相应事件
xfc.xysj(true)

// 移除视图，可用于暂时隐藏悬浮视图
xfc.yc()

// 添加视图，隐藏后需要再显示就添加回来
xfc.tj()

// 更新，在对悬浮窗的位置、大小等操作后，需要调用更新。
xfc.gx()

// 注意，需要给予应用权限，否则无法显示


【列表适配器的操作】
用法：

// 获取列表控件
s lb = st.lb(zy.i.lb1)

// 获取列表适配器
// 输入界面对象（item.iyu），输入布局资源
s lbspq = lb.lbspq(item.lei, zy.b.item)
// v7 列表的适配器
//s v7lbspq = lb.v7lbspq(item.lei, zy.b.item)


// 单项目载入布局完成后，调用事件；可用于单项目布局的调整
s lbspq2 = lb.lbspq(item.lei, zy.b.item)(ua,pn,vw){
// 载入布局完成后调用

}


// 这里是 界面 item.iyu 上面的2个控件的ID
s ids = { zy.i.wb1, zy.i.wb2 }
// 对应设置显示的数据值
s values = { "小明", "18岁" }
// 添加到列表中
lbspq.j(ids, values)

// 如果需要给列表中图像控件设置图像，可设置路径 或远程网络图像，如
// 这里是 界面 item.iyu 上面的2个控件的ID
// s ids = { zy.i.wb1, zy.i.wb2, zy.i.tx1, zy.i.tx2 }
// 对应设置显示的数据值
// s values = { "小明", "18岁", "%1.png", "http://abc.com/1.png" }
// 添加到列表中
// lbspq.j(ids, values)


// 对列表适配器中数据修改后，记得刷新数据
lbspq.sx()

// 删除指定位置的数据
s sc = lbspq.sc(0)

// 删除所有数据
lbspq.sc()

// 获取指定位置的数据
s hq = lbspq.hq(0)

// 获取指定位置的指定ID的数据
s hq2 = lbspq.hq(0, zy.i.wb2)

// 设置指定位置的数据对象
lbspq.sz(0, hq)

// 设置指定位置的指定ID的数据
lbspq.sz(0, zy.i.wb2, "18岁")

// 获取适配器中数据项目的总数
s cd = lbspq.zs()

// 其中列表的项目所用的布局是界面 item.iyu 上面的布局，并且布局控件可以设置事件。

// 在其事件中获取相关列表适配器数据

// 如 item.iyu界面中 ID zy.i.wb1 的控件 的 单击触屏事件 获取 列表适配器数据



// 列表数据操作
s lb2 = sj.lb(vw)

// 获取列表适配器
s lbsqp = lb2.lbspq()

// 获取触发控件的位置
s lbcfwz = lb2.lbcfwz()

// 获取触发控件的数据对象
s lbcfsj = lb2.lbcfsj()

// 获取指定ID的对应数据，获取结果 小明
s lbcfsj2 = lb2.lbcfsj(zy.i.wb1)

// 获取指定位置 和 指定ID的对应数据，获取结果 小明
s lbsj1 = lb2.lbsj(0, zy.i.wb1)

// 获取指定位置数据对象
s lbsj2 = lb2.lbsj(0)

// 获取列表数据对象
s lbsj3 = lb2.lbsj()

// 获取项目根视图控件
s lbxmst = lb2.lbxmst()


【xt.fsdx 发送短信】
用法：
s a = "10086"
s b = "0"
xt.fsdx(a, b)

注意:测试时只显示syso日志，不直接 发送短信，打包即可。

【xt.bddh 拨打电话】
用法：
s a = "10086"
xt.bddh(a)

注意:测试时只显示syso日志，不直接 拨出号码，打包即可。

【xt.sj 当前时间】
用法：
s a = 0
s b = xt.sj(a)
gj.sc(b)

说明：
第一个参数为时间类型

[数字类型]
0：2014-07-07 09:10:08
1：2014/07/07 09:10:08
2：2014-07-07
3：09:10:08
4：18144133553151
5：07-07 09:10:08
6：2014年07月07日 09:10:08
[字符类型，输入字符形式需引号概括]
%1$tY 年
%1$tm 月
%1$td 日
%1$tH 时
%1$tM 分
%1$tS 秒
%1$tL 毫秒
%1$tA 星期几 或 %1$ta 星期几

【获取屏幕相关分辨率】

用法：

//获取屏幕宽度
s k = xt.pm().k
//获取屏幕高度
s g = xt.pm().g

//获取顶部状态栏高度
s ztl = xt.pm().ztl

// 状态栏 false为隐藏 true为显示
xt.pm().ztl(false)

// 设置状态栏颜色
// 输入状态栏颜色（#00000000为透明），状态栏文字颜色（0为白色，1为黑色）
xt.pm().ztl("#ffffff", 1)

//获取底部虚拟按键高度
s xnaj = xt.pm().xnaj

// 底部虚拟按键 false为隐藏 true为显示
xt.pm().xnaj(false)

// 设置屏幕 false为竖屏 true为横屏
xt.pm().hsp(true)

// 设置屏幕亮度 1 - 100
xt.pm().ld(50)

【xt.dkyy 打开App应用】
用法：
xt.dkyy("com.iapp")

//或 带有指定类名的启动
xt.dkyy("com.iapp", "com.iapp.MakeiApp")

【xt.yylb 获取App列表】
用法：
// 输入获取是否包含系统应用
s sz = xt.yylb(false)
xh s app, sz
{
// 包名
gj.sc(app.bm)

// 图标
gj.sc(app.tb)

// 标题
gj.sc(app.bt)

// 版本
gj.sc(app.bb)

// 版本号
gj.sc(app.bbh)
}


【xt.xzyy 卸载应用】
用法：
xt.xzyy("com.iapp")

说明：
输入应用包名

【wl.scwj 上传文件】
用法：
s a = "http://abc.com/upfile.php"
s b = { "filename=iApp我的应用.apk", "test=非常好的应用哦" }
s c = { "%abc/iApp.apk", "%abc/iApp2.apk" }
s d = "utf-8"

// 上传文件
s e = wl.scwj(a, b, c, d)


// 设置 上传文件的name标签（非文件名），这个标签对应后台的设置，设置不当可能后台无法接收到文件
s a = "http://abc.com/upfile.php"
s b = { "filename=iApp我的应用.apk", "test=非常好的应用哦" }
// 将这个文件设置为 img name标签，不设置的话默认为 file
s c = { "img\n%abc/iApp.apk"}
// 支持多文件上传，多文件设置name标签需要在尾部加 []  比如 img[]
s c = { "img[]\n%abc/iApp.apk", "img[]\n%abc/iApp2.apk" }
s d = "utf-8"
// 上传文件
s e = wl.scwj(a, b, c, d)


//设置 header文件头，文件头包括了Cookie，User-Agent设备型号。。
s f = "User-Agent=Mozilla/5.0 (iPad; U; CPU OS 6_0 like Mac OS X; zh-CN; iPad2)||Cookie=aa:123;bb:456;||accept-language=zh-CN"
s g = wl.scwj(a, b, c, d, f)

【动态创建控件】
用法：
// 创建文本控件
wb wb = st.wb()
// 设置ID 也可以不设置ID
wb.id(10087)
// 设置宽高 -1为最大，-2为自适应
wb.kg(-2, -2)
// 其他的设置
wb.zf("你好")

// 获取一个显示的布局控件作为父控件
xxbj xxbj = st.xxbj(zy.i.xxbj1)

// 添加控件
xxbj.j(wb)


// 删除子视图
s a = xxbj.sc(wb)

// 删除全部子视图
s b = xxbj.scqb()

// 获取子视图对象列表
s c = xxbj.zlb()

// 获取从父控件中获取指定视图
s d = st.wb(zy.i.xxbj1, 10087)

// 获取控件原对象
xxbj xxbj = st.xxbj(zy.i.xxbj1)
s e = xxbj.st

// 获取控件原View对象
s e2 = st.st(zy.i.xxbj1)

// 获取控件原View对象，输入父控件ID或对象，输入要获取的控件ID
s e2 = st.st(zy.i.xxbj1, 10087)

【gj.txcl 图像处理】
用法：
s t = gj.txcl("%1.jpg")

// 是否开启编辑图像后更新对象；true时如你对图像进行了裁剪，再次裁剪则以上次裁剪的基础进行继续裁剪。以及裁剪后可直接保存图像；false时图像编辑后，再次编辑还是以原始图像状态进行编辑。
t.gxtx(true)

// 获取图像大小
// 图像的宽
s k = t.k
// 图像的高
s g = t.g

// 裁剪图像区域（像素）：x坐标:80，y坐标:90，裁剪宽度:50，裁剪高度:60
s a = t.cj(80, 90, 50, 60)

// 旋转图像，负值为逆时针旋转，正值为顺时针旋转
s b = t.xz(180)

// 缩放图像，值小于1 则为缩小，否则为放大
s c = t.sf(0.5)

// 缩放图像，输入指定的宽高进行缩放
s c2 = t.sf(100, 200)

// 图像反转，0为水平反转，1为垂直反转
s d = t.fz(1)

// 保存图像
s e = t.bc("%1.jpg")

// 保存图像，并指定图像质量(1-100)
s e2 = t.bc("%1.jpg", 100)


// 输入指定的图像对象进行保存
s t2 = gj.txcl("%1.jpg")
s a2 = t2.cj(80, 90, 50, 60)
// 输入图像对象，保存的路径，指定图像质量(1-100)
s e3 = t2.bc(a2, "%1.jpg", 100)


【xt.jqbxr 剪切板写入文本】
用法：
s a = "nihao"
xt.jqbxr(a)

说明：
可用于复制到剪切板，其他应用可获取到此数据。

【xt.jqbhq 剪切板获取文本】
用法：
s a = xt.jqbhq()
gj.sc(a)

说明：
可获取剪切板数据，得到其他地方写入的剪切板数据。

【xt.sbxm 设备休眠】
用法：

// 设置为不休眠
xt.sbxm(false)

说明：
设置后手机将不休眠，不锁屏。默认为 true 需要休眠。注意需要权限 android.permission.WAKE_LOCK

【视频播放】
用法：

// 获取视频控件
s sp1 = st.sp(zy.id.sp1)

// 输入媒体数据源 3gp、MP4、avi
s mt = sp1.zrsp("%abc.mp4")

// 网络媒体，支持协议 http / https / rtsp
s mt2 = sp1.zrsp("http://www.abc.com/abc.mp4")

// 带回调的方法
s mt = sp1.zrsp("%abc.mp4"){
// 播放结束后调用

}

// 播放
sp1.bf()

// 暂停
sp1.zt()

// 恢复
sp1.hf()

// 停止
sp1.tz()

// 当前播放状态，返回整数型 1正在播放，0没有播放，-1获取失败
s bfzt = sp1.bfzt()

// 获取媒体的时长（毫秒）
s mtsc = sp1.mtsc()

// 获取当前播放位置（毫秒）
s bfwz = sp1.bfwz()

// 指定播放的位置（毫秒）
// 1分钟后
s tz = 60000
sp1.zdbfwz(tz)


【加载界面】
用法：

// 获取一个线性布局
s xxbj = st.xxbj(zy.i.xxbj1)

// 设置要被加载的界面 与 界面的布局资源，值为数组可传入多个
s iyus = { item.lei }
s iyuzy = { zy.b.csjm }

// 添加
xxbj.jm(iyus, iyuzy)


// 滑动窗体与 侧滑窗体 使用方法是一样的
s iyus = { item.lei, item2.lei, item3.lei }
s iyuzy = { zy.b.csjm, zy.b.csjm2, zy.b.csjm3 }

// 添加
xxbj.jm(iyus, iyuzy)


【数据转换】
用法：

s a = 123
s b = 123.12
s c = "abc"

// 转换为字符串
s zfc = sj.zh(b).zstring()

// 转为布尔型
s brx = sj.zh(b).zboolean()

// 转为布尔型，如果转换失败设置结果为false
s brx2 = sj.zh(b).zboolean(false)

// 转为整数
s zsx = sj.zh(b).zint()
s zsx2 = sj.zh(b).zlong()

// 转为整数，如果转换失败设置结果为0
s zsx3 = sj.zh(b).zint(0)
s zsx4 = sj.zh(b).zlong(0)

// 转为浮点型
s fdx = sj.zh(b).zfloat()
s fdx2 = sj.zh(b).zdouble()

// 转为浮点型，如果转换失败设置结果为0
s fdx3 = sj.zh(b).zfloat(0)
s fdx4 = sj.zh(b).zdouble(0)

// dip转换px
s px = sj.zh(a).dpzpx()

// px转换dip
s px = sj.zh(a).pxzdp()

// px转换sp
s px = sj.zh(a).pxzsp()

// sp转换px
s px = sj.zh(a).spzpx()

// 获取数据类型
s lx = sj.zh(c).lei()

【设备信息】
用法：

// 设备SDK
s sdk = xt.sbxx().sdk

// 设备版本
s bb = xt.sbxx().bb

// 设备品牌
s pp = xt.sbxx().pp

// 设备型号
s xh2 = xt.sbxx().xh

// 设备cpu型号
s cpuxh = xt.sbxx().cpuxh()

// 设备cpu频率
s cpupl = xt.sbxx().cpupl()

// 设备cpu类型
s cpulx = xt.sbxx().cpulx()

// 设备imei，需要权限 android.permission.READ_PHONE_STATE
s cpulx = xt.sbxx().imei()

// 设备imsi，需要权限 android.permission.READ_PHONE_STATE
s cpulx = xt.sbxx().imsi()

// 获取设备唯一识别码
s id = xt.sbxx().id()


【xt.ycxnjp 强制隐藏虚拟键盘】
用法：

// 隐藏虚拟键盘
xt.ycxnjp()


【wl.xzgl 下载管理】
用法：
s a = "%down/temp"
s b = "%down/save"

//并发线程上限数量（-1为默认，1为单任务，N为多任务）线程数量过多可能造成卡顿
s c = -1

s d = 25000
s e = false

// 输入文件保存路径
s xzgl = wl.xzgl(b){

gj.sc("每个项目下载后都会调用")
}

// 输入临时文件路径，文件保存路径
s xzgl = wl.xzgl(a, b){

gj.sc("每个项目下载后都会调用")
}

// 输入临时文件路径，文件保存路径，并发线程上限数量，超时，是否覆盖重复
s xzgl = wl.xzgl(a, b, c, d, e)(ii, dt, dr){

gj.sc("每个项目下载后都会调用")

// 获取相关数据

// ii 下载项目序号
// dt 下载项目对象
// dr 下载管理器

// 下载文件的字节大小
s dx = dt.dx

// 已下载字节数
s yxz = dt.yxz

// 下载项目标题
s bt = dt.bt

// 网址
s wz = dt.wz

// 文件路径
s wjlj = dt.wjlj

// 自定义数据
s sj2 = dt.sj

// 获取状态，0为还未开始，1正在运行，2已完成
s zt = dt.zt()

}



// 重设置目录
xzgl.ml(a, b)


s f = "http://abc.com/1.jpg"

// 添加下载项目
// 输入网址
xzgl.j(f)

// 输入网址，自定义数据
xzgl.j(f, "自定义数据")

// 输入网址，保存的路径，自定义数据
xzgl.j(f, "%abc1.jpg", "自定义数据")

// 输入网址，保存的路径，项目标题，自定义数据
xzgl.j(f, "%abc1.jpg", "name", "自定义数据")

// 获取下载列表
s lb = xzgl.lb


【wl.xzglq 下载管理器】
用法：
// 临时文件存放路径
s a = "%down/temp"
// 下载文件存放路径
s b = "%down/save"

//同时下载任务
s c = 3

//单任务开启线程的上限；比如你同时下载3个任务，单任务线程上限为3 那么总共就开启了 9个线程进行下载
s d = 3

//连接失败重试次数
s e = 3

//连接超时时间，毫秒
s f = 20000


// 输入临时文件路径，文件保存路径
s xzglq = wl.xzglq(a, b)
(zt, wjlj, data, dt){
// zt 状态  0为等待下载；1为正在下载；2为下载完成；3下载已经暂停或停止；4安装中；-1下载失败
// wjlj 文件路径  data 自定义的数据  dt 下载对象

gj.sc(zt + " 每个项目下载后都会调用 " + wjlj)

}


// 输入临时文件路径，文件保存路径，同时下载任务，单任务开启线程的上限，连接失败重试次数，连接超时时间
s xzglq = wl.xzglq(a, b, c, d, e, f)
(zt, wjlj, data, dt){
// zt 状态  0为等待下载；1为正在下载；2为下载完成；3下载已经暂停或停止；4安装中；-1下载失败
// wjlj 文件路径  data 自定义的数据  dt 下载对象

/*
下载对象的字段与方法
//下载配置
dt.downConfig
//下载ID
dt.id
//下载URL链接
dt.lj
//指定文件保存位置
dt.wjlj
//当前url的md5
dt.ljmd5
//指定文件保存目录
dt.ml
//指定文件保存的文件名
dt.wjm
//文件的大小
dt.wjdx
//已下载
dt.yxz
//下载速度
dt.xzsd
//下载百分比
dt.xzbfb
//下载状态 0为等待下载；1为正在下载；2为下载完成；3下载已经暂停或停止；4安装中；-1下载失败；-2已删除
dt.xzzt
//单任务启动线程上限
dt.xcsx
//单任务已启动线程数量
dt.xcsl
//是否停止当前下载；true为停止
dt.sftzxz
//标题
dt.bt
//用户自定义数据
dt.sj
//下载管理器对象
dt.xzglq

//开始下载 注意下载状态为 0 3 -1 时才可调用成功
s dtks = dt.ks()
//停止下载 注意下载状态为 1 时才可调用成功
s dttz = dt.tz()

*/

gj.sc(zt + " 每个项目下载后都会调用 " + wjlj)

}


s wz = "http://abc.com/1.jpg"

// 添加下载项目
// 输入网址，文件名（注意是文件名不是完整路径）
xzglq.j(wz, "abc1.jpg")

// 输入网址，文件名，自定义数据
xzglq.j(wz, "abc1.jpg", "自定义数据")

// 输入网址，文件名，项目标题，自定义数据
xzglq.j(wz, "abc1.jpg", "name", "自定义数据")

// 输入网址，目录路径，文件名，项目标题，自定义数据
xzglq.j(wz, "%down/save2", "abc1.jpg", "name", "自定义数据")

// 开始下载，每次添加下载项目后会自动开始下载
xzglq.ks()

// 获取下载，根据下载连接来获取已存在的下载，返回下载对象
s dt = xzglq.hqxz(f)


// 获取下载列表
s lb = xzglq.lb


【wl.web Web服务器】
用法：

// web服务器开启后，可用浏览器进行访问你的站点

//本机访问地址 http://127.0.0.1:8888/iyu-helpV5.0.txt
//局域网访问地址 http://局域网IP:8888/iyu-helpV5.0.txt
//外网访问地址 http://外网IP:8888/iyu-helpV5.0.txt

//局域网IP 可在手机设置里找，一般在wifi设置 或 系统关于、状态等里面。
//外网，需要有外网IP。并且需要端口映射8888端口。


// 需要启用线程
gj.xc{

// 创建web站点
// 输入端口，站点的文件夹路径
s web = wl.web(8888, "%iApp")

// 开始启动web服务器，这里线程会被堵塞
web.ks()

// 下面的代码将在服务器关闭后执行
gj.sc("服务器已关闭")

}


// 使用裕语言V5扩展开发站点
// 例如，做个用户后台。先解析http请求头ct变量，这是字符串类型，你可以先打印数据出来看看字符串格式，再截取需要的
// 可以截取 http请求头 的 post 或 get 数据，这是用户提交的数据。然后使用数据库 sj.sjk 进行保存或 查询，最后输出需要输出的html内容。

gj.xc{

// 创建web站点
// 输入端口，站点的文件夹路径
s web = wl.web(8888, "%iApp")(wb,sk,ct){

//wb 是站点对象，就是s web对象
//sk 选择键的对象，用于数据处理
//ct 用户发送连接的http请求头，需要你自行解析该字符串，还包含get/post等数据
gj.sc("http请求头:" + ct)

// 通过解析http请求头，截取需要的字符串
// 然后用裕语言V5代码处理相关数据
// 然后输出你想要的数据

s html = "这是我需要输出的<b>数据</b>啊"

// 输出
wb.sc(sk, html)

}

// 开始启动web服务器，这里线程会被堵塞
web.ks()

// 下面的代码将在服务器关闭后执行
gj.sc("服务器已关闭")

}


//子方法

// 开始启动web服务器
web.ks()

// 关闭web服务器
web.gb()

//404错误的自定义显示内容
web.cw404("找不到文件")

//500错误的自定义显示内容
web.cw500("文件内部错误")

//默认页面文件名
web.mrym("index.htm")

//访问的文件未添加MIME时，会无法显示，如果给它设置个默认的MIME，就可以显示了
web.mime("text/html;charset=UTF-8")
//web.mime("*/*")

//添加文件的MIME
s b1 = web.mime(".jar", "application/x-zip-compressed")

//输出自定义数据
wb.sc(sk, "需要输出的数据内容")

//输入选择键的对象，返回状态，输出的内容，输出内容类型，自定义输出的http头信息
s headers = { "Server: iAppServer" }
wb.sc(sk, 200, "需要输出的数据内容", "text/html;charset=UTF-8", headers)


说明：
可用于web服务器架设，切换后台时需注意：系统可能的进行内存回收，导致服务器被销毁了。

【wl.tjz 套接字 Socket】
用法：

// 需要启用线程
gj.xc(){
// 创建服务端
// 输入服务端口，服务端超时限制(指定时间内无新连接则关闭服务器,0为无限制)，客户端超时限制(已连接的客户端指定时间内未通信则关闭,0为无限制)，是否接收新连接请求
s tjz = wl.tjz(6666, 0, 0, true)(so,sr){
// so 服务端对象
// sr 新连接对象

gj.sc(sr.ip() + ":" + sr.dk() + ":" + sr.bjip() + ":" + sr.bjdk())

},(sr,te,mg,bs){
// sr 连接对象
// te 数据类型，0为无数据头字节数组，1为带数据头字符串，2为带数据头文件，3为带数据头字节数组
// mg 数据信息，数据类型为1时值为对应的字符串，数据类型为2时值为文件的后缀
// bs 数据的字节数组

gj.sc(sr + ":" + te + ":" + mg + ":" + bs.length)

}

// 开始，这里线程会被堵塞
tjz.ks()

// 下面的代码将在服务端关闭后执行
gj.sc("服务端已关闭")

}


// 需要启用线程
gj.xc(){
// 创建客户端
// 输入服务器IP，服务端口，超时限制(指定时间内未通信则关闭,0为无限制)
s tjz = wl.tjz("192.168.1.100", 6666, 0)(so,sr){
},(sr,te,mg,bs){
// sr 连接对象
// te 数据类型，0为无数据头字节数组，1为带数据头字符串，2为带数据头文件，3为带数据头字节数组
// mg 数据信息，数据类型为1时值为对应的字符串，数据类型为2时值为文件的后缀
// bs 数据的字节数组

gj.sc(sr + ":" + te + ":" + mg + ":" + bs.length)
}

// 开始
tjz.ks()

}


// 更多方法

// 重启
tjz.cq()

// 开始启动或连接
tjz.ks()

// 连接总数
s ljzs = tjz.ljzs()

// 获取连接列表
s ljlb = tjz.lj()

// 获取指定序号的连接
s lj = tjz.lj(0)

// 连接清空
tjz.ljqk()

// 获取当前是否已关闭
s sfgb = tjz.sfgb()

// 关闭释放
tjz.gb()

// 获取服务器对象
s fwd = tjz.fwd()

// 获取本机的IP
s bjip = tjz.bjip()

// 获取本机的端口
s bjdk = tjz.bjdk()

// 输出数据，返回发送成功数量，如果是服务端则为群发
// 可输出多种类型数据，字符串，字节数组，文件等
gj.xc(){
s sc1 = tjz.sc("nihao")
}

// 输出数据，需要开线程
gj.xc(){
// 输入数据类型，输入数据内容
s sc2 = tjz.sc(1, "nihao")
// 输出文件
//s sc2 = tjz.sc(2, "%a.png")
}


// sr 连接对象的方法

// 获取远程连接的IP
s ip = sr.ip()

// 获取远程连接的端口
s dk = sr.dk()

// 获取本机的IP
s bjip = sr.bjip()

// 获取本机的端口
s bjdk = sr.bjdk()

// 获取当前是否已关闭
s sfgb = sr.sfgb()

// 重启连接
sr.cq()

// 关闭释放
sr.gb()

// 获取连接socket对象
s ljdx = sr.ljdx()

// 设置自定义数据
sr.sj("abcd")

// 获取自定义数据
s sj1 = sr.sj()

// 设置自定义数组数据
s sz = { "abcd", "efg" }
sr.szsj(sz)

// 获取自定义数组数据
s sjsz = sr.szsj()

// 输出数据，返回发送成功数量，如果是服务端则为群发
// 可输出多种类型数据，字符串，字节数组，文件等
gj.xc(){
s sc1 = sr.sc("nihao")
}

// 输出数据
// 输入数据类型，输入数据内容
gj.xc(){
s sc2 = sr.sc(1, "nihao")
// 输出文件
//s sc2 = sr.sc(2, "%a.png")
}


关于数据头：
数据头是为了更佳简便的使用套接字，为固定模式和长度；
数据头固定为32位；6位固定标识0-5，1位数据类型6-6，10位数据长度7-16，15位文件后缀17-31

// 数据类型: 1为字符串，2为文件，3为字节数组

// java开头固定字节标识 32, -93, 93, 0, 63, -63
// c#开头固定字节标识 32, 163, 93, 0, 63, 193


【wl.sjb 用户数据报协议 UDP】
用法：

// 需要启用线程
gj.xc(){

// 输入本地服务端的端口
s sjb = wl.sjb(6666)(cp,dp,bs,ip,dk){
// cp 数据报协议对象
// dp 接收数据对象
// bs 接收的字节数组
// ip 发送者IP
// dk 发送者端口

gj.sc(cp + ":" + dp + ":" + bs + "+" + bs.length + ":" + ip + ":" + dk)
}

// 开始，这里线程会被堵塞
sjb.ks()

// 下面的代码将在服务端关闭后执行
gj.sc("服务端已关闭")

}


// 需要启用线程
gj.xc(){

// 输入远程连接IP，远程连接的端口，输入本地服务端的端口
s sjb = wl.sjb("192.168.1.101", 6666, 7777)(cp,dp,bs,ip,dk){
// cp 数据报协议对象
// dp 接收数据对象
// bs 接收的字节数组
// ip 发送者IP
// dk 发送者端口

gj.sc(cp + ":" + dp + ":" + bs + "+" + bs.length + ":" + ip + ":" + dk)
}

// 开始，这里线程会被堵塞
sjb.ks()

// 下面的代码将在服务端关闭后执行
gj.sc("服务端已关闭")

}

// 更多方法

// 开始
sjb.ks()

// 关闭
sjb.gb()

// 设置最大接收数据长度，需在开始前调用；默认5KB，值越大越可能丢包发送失败。建议10KB内
sjb.sjcd(1024*5)

// 获取连接对象
s lj = sjb.lj()

// 获取连接的IP
s ip = sjb.ip()

// 获取连接的端口
s dk = sjb.dk()

// 获取本机的IP
s ip = sjb.bjip()

// 获取本机的端口
s dk = sjb.bjdk()

// 获取连接是否已释放
s sfgb = sjb.sfgb()

// 输出数据
gj.xc(){
s sc1 = sjb.sc("nihao")
}

// 输出数据
// 输入发送的IP，发送的端口，发送的数据
gj.xc(){
s sc2 = sjb.sc("192.168.1.102", 7777, "nihao")
}


【zf.zzbds 正则表达式】
用法：

//字符串
s a = "qqqq123456eee"
//正则表达式
s b = "([a-z]+)(\\d+)"
//更多参数
s c = 0

// 获取正则表达式对象
s zz = zf.zzbds(a, b, c)

//替换成，将替换全部
s e = zz.thqb("1:$1, 2:$2")

//替换成，只替换第一个
s e2 = zz.thyg("1:$1, 2:$2")

//返回是否匹配成功，需字符串被完全匹配，赋值返回true或 false
s e3 = zz.sfppcg()

//开始匹配 或 匹配下一个，赋值返回true或 false
s e4 = zz.pp()

//给定位置序号进行匹配，赋值返回true或 false
s e5 = zz.pp(1)

//获取匹配组的数量，当前为2组：([a-z]+)、(\d+)
s e6 = zz.ppzsl()

//获取第1组匹配到的子字符串在字符串中的开头位置 
s e7 = zz.kswz(1)

//获取第1组匹配到的子字符串在字符串中的结尾位置 
s e8 = zz.jswz(1)

//获取第1组匹配到的子字符串
s e9 = zz.zf(1)
//获取第2组匹配到的子字符串
s e10 = zz.zf(2)

【xt.gn 设备功能操作】
用法：

s gn = xt.gn()

// 闪光灯 需要权限 android.permission.CAMERA

// 闪光灯开启
gn.sgd()

// 闪光灯停止
gn.sgdtz()


// 振动 需要权限 android.permission.VIBRATE

// 振动 1秒钟
s zd1 = gn.zd(1000)

//静止1秒，振动1秒，静止1秒，振动1秒，静止1秒，振动1秒，静止1秒，..， 并且不重复
//输入振动规则，输入是否重复循环执行
s gz = { 1000, 2000, 3000, 4000 }
s zd2 = gn.zd(gz, false)

//强制停止振动器
gn.zdtz()

// 获取振动状态
s zd3 = gn.zd()


// 录音 需要权限 android.permission.RECORD_AUDIO
s ly1 = gn.ly("%1.amr")

// 录音停止
s ly2 = gn.lytz()



// 录制屏幕
//输入储存录制文件路径，输入视频宽度，输入视频高度，输入视频码率（码率可以设置大些视频会清晰些），输入视频帧率
gn.lpm("%123.mp4", 1280, 720, 1024000, 30)

//开始录制
gn.lpmks()

//停止录制
gn.lpmtz()

//释放资源
gn.lpmsf()

//判断是否正在录制
gn.zzlpm()

//录屏幕回调；注意：需要此代码放入 回调结果 界面事件，否则将无法录制
gn.lpmhd(re, rc, it)


说明：
用于手机屏幕录制。

注意：
录屏幕仅支持系统Android 5.0以及以上才有效果！
Android 5.0以下的系统，无效果！



// 截屏
s jp1 = gn.jp("%123.jpg", 70)


// 调用拍摄相片，拍摄后会调用 界面事件》回调结果  方法第一个参数结果为 63930
// 输入拍摄的相片保存位置
gn.psxp("%1.jpg")


// 相册选择，选择后会调用 界面事件》回调结果  方法第一个参数结果为 63931
// 需要通过 sj.hquri(it) 来获取结果
gn.xcxz()

// 相册选择获取结果
// 输入 界面事件》回调结果 方法的第三个参数
s xcxz1 = sj.hquri(it)


// 视频拍摄，拍摄后会调用 界面事件》回调结果  方法第一个参数结果为 63932
// 需要通过 sj.hquri(it) 来获取结果
gn.spps()

// 相册视频拍摄结果
// 输入 界面事件》回调结果 方法的第三个参数
s xcxz2 = sj.hquri(it)



// 系统截屏，可全系统截屏 需5.0以及以上设备

// 1. 首先需系统截屏初始化，初始化后会异步调用 回调结果 界面事件
gn.xtjpcsh();

//2. 系统截屏回调 返回null 则失败；注意：需要此代码放入 回调结果 界面事件，否则将无法截屏
gn.xtjphd(re, rc, it)

//3. 然后在其他事件里就可以截屏了，你也可以弄个悬浮按钮的事件来执行截屏代码

//开始系统截屏返回 图像对象
s b = gn.xtjp()

//开始系统截屏，输入延迟毫秒（3秒）
s b2 = gn.xtjp(3000)

//开始系统截屏，输入延迟毫秒（3秒），保存图像路径
s b2 = gn.xtjp(3000, "%1.png")

//开始系统截屏，输入延迟毫秒（3秒），保存图像路径，图像的质量（1-100）
s b2 = gn.xtjp(3000, "%1.png", 90)


// 传感器，如果设备不支持该传感器将返回 变量c 为 false
输入传感器类型值，输入传感器延迟类型
s c = gn.cgq(1, 2)(se){
//传感器已更新
// se 参数对象，用于传感器参数的传递

// 获取传感器更新的数值数组，这个数值数组是float[]类型，里面是传感器的实时反馈数据。
s sz = se.values

// 可以根据这数值数组的数据，来进行对应的应用操作等等~ 这里就不演示，这里将数值数组打印出来
xh s a, sz
{
gj.sc("数值:" + a)
}

}, (sr, ag){
//精度变化
// sr 传感器类型对象，注意这是对象。如果要获取对应的 传感器类型值可用 sr.getType()
// ag 新精度值

// 这里根据项目需求来操作
gj.sc("传感器类型值:" + sr.getType())
gj.sc("新精度值:" + ag)

}

//传感器释放，如果你不使用传感器功能了，调用他可以释放掉其占用的内存和监听事件
//gn.cgqsf()

// 传感器延迟类型
  类型值完整类：android.hardware.SensorManager.SENSOR_DELAY_FASTEST
    尽快获取传感器数据
    延迟类型值：0

  类型值完整类：android.hardware.SensorManager.SENSOR_DELAY_GAME
    适用于游戏
    延迟类型值：1

  类型值完整类：android.hardware.SensorManager.SENSOR_DELAY_UI
    适用于用户界面
    延迟类型值：2

  类型值完整类：android.hardware.SensorManager.SENSOR_DELAY_NORMAL
    适用于屏幕方向更改（默认）
    延迟类型值：3


// 传感器类型值与类型说明
  类型值完整类：android.hardware.Sensor.TYPE_ACCELEROMETER
    加速度传感器（重力感应），单位是m/s2，测量应用于设备X、Y、Z轴上的加速度
    传感器类型值：1

  类型值完整类：android.hardware.Sensor.TYPE_MAGNETIC_FIELD
    磁力传感器，单位是uT(微特斯拉)，测量设备周围三个物理轴（x，y，z）的磁场
    传感器类型值：2

  类型值完整类：android.hardware.Sensor.TYPE_ORIENTATION
    方向传感器,测量设备围绕三个物理轴（x，y，z）的旋转角度
    传感器类型值：3

  类型值完整类：android.hardware.Sensor.TYPE_GYROSCOPE
    陀螺仪传感器，单位是rad/s，测量设备x、y、z三轴的角加速度
    传感器类型值：4

  类型值完整类：android.hardware.Sensor.TYPE_LIGHT
    光线感应传感器，单位lx，检测周围的光线强度
    传感器类型值：5

  类型值完整类：android.hardware.Sensor.TYPE_PRESSURE
    压力传感器，单位是hPa(百帕斯卡)，返回当前环境下的压强
    传感器类型值：6

  类型值完整类：android.hardware.Sensor.TYPE_TEMPERATURE
    温度传感器，目前已被TYPE_AMBIENT_TEMPERATURE（传感器类型值： 13）替代
    传感器类型值：7

  类型值完整类：android.hardware.Sensor.TYPE_PROXIMITY
    距离传感器，单位是cm，用来测量某个对象到屏幕的距离
    传感器类型值：8

  类型值完整类：android.hardware.Sensor.TYPE_GRAVITY
    重力传感器，单位是m/s2，测量应用于设备X、Y、Z轴上的重力
    传感器类型值：9

  类型值完整类：android.hardware.Sensor.TYPE_LINEAR_ACCELERATION
    线性加速度传感器，单位是m/s2，该传感器是获取加速度传感器去除重力的影响得到的数据
    传感器类型值：10

  类型值完整类：android.hardware.Sensor.TYPE_ROTATION_VECTOR
    旋转矢量传感器，旋转矢量代表设备的方向
    传感器类型值：11

  类型值完整类：android.hardware.Sensor.TYPE_RELATIVE_HUMIDITY
    湿度传感器，单位是%，来测量周围环境的相对湿度
    传感器类型值：12

  类型值完整类：android.hardware.Sensor.TYPE_AMBIENT_TEMPERATURE
    温度传感器，单位是℃
    传感器类型值： 13

  类型值完整类：android.hardware.Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED
    未校准磁力传感器，提供原始的，未校准的磁场数据
    传感器类型值：14

  类型值完整类：android.hardware.Sensor.TYPE_GAME_ROTATION_VECTOR
    游戏动作传感器，不收电磁干扰影响
    传感器类型值：15

  类型值完整类：android.hardware.Sensor.TYPE_GYROSCOPE_UNCALIBRATED
    未校准陀螺仪传感器，提供原始的，未校准、补偿的陀螺仪数据，用于后期处理和融合定位数据
    传感器类型值：16

  类型值完整类：android.hardware.Sensor.TYPE_SIGNIFICANT_MOTION
    特殊动作触发传感器
    传感器类型值：17

  类型值完整类：android.hardware.Sensor.TYPE_STEP_DETECTOR
    步行检测传感器，用户每走一步就触发一次事件
    传感器类型值：18

  类型值完整类：android.hardware.Sensor.TYPE_STEP_COUNTER
    计步传感器
    传感器类型值：19

  类型值完整类：android.hardware.Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR
    地磁旋转矢量传感器，提供手机的旋转矢量，当手机处于休眠状态时，仍可以记录设备的方位
    传感器类型值：20

  类型值完整类：android.hardware.Sensor.TYPE_HEART_RATE
    心率监测传感器，报告的值是每分钟心跳的心率。
    传感器类型值：21

  类型值完整类：android.hardware.Sensor.TYPE_TILT_DETECTOR
    倾斜传感器，每次检测到倾斜事件时，如果2秒窗口平均重力的方向在自激活传感器以来至少35度。这是一个唤醒传感器。
    传感器类型值：22

  类型值完整类：android.hardware.Sensor.TYPE_WAKE_GESTURE
    手势唤醒传感器，唤醒手势传感器可根据设备特定的运动唤醒设备。
    传感器类型值：23

  类型值完整类：android.hardware.Sensor.TYPE_GLANCE_GESTURE
    手势唤醒传感器，传感器可短暂打开屏幕，使用户能够根据特定动作浏览屏幕上的内容。设备应稍后关闭屏幕。
    传感器类型值：24

  类型值完整类：android.hardware.Sensor.TYPE_PICK_UP_GESTURE
    拾取传感器，无论在何处捡起设备，此类传感器都会触发。
    传感器类型值：25

  类型值完整类：android.hardware.Sensor.TYPE_WRIST_TILT_GESTURE
    腕倾斜手势传感器，当设备表面朝向用户倾斜时，会触发此类传感器。
    传感器类型值：26

  类型值完整类：android.hardware.Sensor.TYPE_DEVICE_ORIENTATION
    设备的当前方向传感器，在内部用于自动旋转和扬声器旋转。
    传感器类型值：27

  类型值完整类：android.hardware.Sensor.TYPE_POSE_6DOF
    6个自由度的姿势传感器，与android.hardware.Sensor.TYPE_ROTATION_VECTOR（传感器类型值：11）相似，但有额外的增量从任意参考点转换。
    传感器类型值：28

  类型值完整类：android.hardware.Sensor.TYPE_STATIONARY_DETECT
    固定检测传感器。
    传感器类型值：29

  类型值完整类：android.hardware.Sensor.TYPE_MOTION_DETECT
    运动检测传感器。
    传感器类型值：30

  类型值完整类：android.hardware.Sensor.TYPE_HEART_BEAT
    运动检测传感器。
    传感器类型值：31

  类型值完整类：android.hardware.Sensor.TYPE_DYNAMIC_SENSOR_META
    动态传感器元事件传感器，动态传感器添加到其中或从中删除动态传感器时，会收到此类型的传感器事件。
    传感器类型值：32

  类型值完整类：android.hardware.Sensor.TYPE_LOW_LATENCY_OFFBODY_DETECT
    低延迟体外检测传感器。
    传感器类型值：34

  类型值完整类：android.hardware.Sensor.TYPE_ACCELEROMETER_UNCALIBRATED
    未校准加速度传感器。
    传感器类型值：35

// 传感器相关权限 android.permission.BODY_SENSORS


【xt.qxgl 权限管理】
用法：
//判断写入权限是否已授权
s qxgl = xt.qxgl()
s xr = qxgl.qx("android.permission.WRITE_EXTERNAL_STORAGE")
gj.sc("写入权限是否已授权:" + xr)


//注意：请求应用权限。请求后结果将在  界面事件》请求权限结果  且参数变量 rc 固定值赋为 60542

//请求当前应用所需的权限
s qxgl = xt.qxgl()
// 将请求当前应用 AndroidManifest 中已配置的权限
qxgl.qqqx()

// 请求单个权限
s qxgl = xt.qxgl()
// 请求写入权限
qxgl.qqqx("android.permission.WRITE_EXTERNAL_STORAGE")

// 请求多个权限
s qxgl = xt.qxgl()
// 同时请求2个及以上的权限，这里用一个数组
s sz = { "android.permission.WRITE_EXTERNAL_STORAGE", "android.permission.READ_PHONE_STATE" }
// 请求写入权限 和 读取电话状态
qxgl.qqqx(sz)


请求权限结果中的例子：
// 该事件的参数介绍 int rc, String[] ps, int[] gr
// int rc 请求代码请求权限时传入的固定代码
// String[] ps 请求的权限列表
// int[] gr 请求的权限列表的状态结果，该数组的长度与请求的权限列表一致
rg rc == 60542
{
  rg ps != null
  {
    s j = ps.length
    xh s i=0, i<j, i++
    {
      rg gr[i] == -1
      {
        gj.sc("请求失败:" + ps[i])
      }
    }
  }
}

【sj.sjk 数据库操作】
用法：
//连接一个私有数据库，如果不存在将自动新建
//输入数据库文件名
s sjk = sj.sjk("iapp.db")


//连接一个公共数据库，如果不存在将自动新建
//输入数据库文件名
s sjk2 = sj.sjk("%iapp.db")

// 获取数据库对象
s sjk3 = sjk.sjk

// 获取数据库是否为新建的
s sjk5 = sjk.xj

// 删除数据库
s sjk6 = sjk.scsjk()

// 释放数据库
s sjk7 = sjk.sfsjk()

// 创建 info 数据表
s table = "_id integer primary key,url text, filename text,status interger"
s sjk8 = sjk.cjsjb("info", table)

// 判断 info 数据表 是否存在
s sjk9 = sjk.czsjb("info")

// 删除 info 数据表
s sjk10 = sjk.scsjb("info")


//在 info 数据表 添加一条数据
// 数据列名
s table = "url,filename,status"
// 对应数据
s data = "'http://abc.com/abc.apk', 'abc.apk', 1"
s sjk11 = sjk.cjsj("info", table, data)


//在 info 数据表 更新数据，若不需要设置条件(_id=1)可设为 null 视为适用于执行所以数据
s sjk12 = sjk.gxsj("info", "status=2", "_id=1")


//在 info 数据表 删除数据，若不需要设置条件(_id=1)可设为 null 视为适用于执行所以数据
s sjk13 = sjk.scsj("info", "_id=1")


//在 info 数据表 查询数据
//查询，若不需要设置条件(status=1 order by _id desc LIMIT 0,1)可设为 null 视为适用于执行所以数据
// LIMIT <跳过的数据数目>, <取数据数目>
s table = "_id,url,filename,status"
s sqlx = "status=1 order by _id desc LIMIT 0,1"
s sjk15 = sjk.cxsj("info", table, sqlx)

//自定义sql查询
s sqlx = "select _id,url,filename,status from info where status=1 order by _id desc"
s sjk16 = sjk.cxsj(sqlx)

// 循环打印数据
xh sjk15.xyh()
{
// 输出 第一列数据， 第二列数据
gj.sc(":" + sjk15.sj(0)+ ", " + sjk15.sj(1));
}

// 更多操作

//获取光标对象的第一列数据
s sj1 = sjk15.sj(0)

//获取光标对象有多少列
s sj2 = sjk15.cxls()

//获取总共查询到多少行数据
s sj3 = sjk15.cxhs()

//光标对象移到下一行数据
s sj5 = sjk15.xyh()

//光标对象移到上一行数据
s sj6 = sjk15.syh()

//光标对象移到第一行数据
s sj7 = sjk15.dyh()

//光标对象移到最后第一行数据
s sj8 = sjk15.zhyh()

//光标对象移到指定第3条数据
s sj9 = sjk15.zdwz(2)

//获取光标对象当前位置
s sj10 = sjk15.hqwz()

//释放数据查询
s sj11 = sjk15.sf()



//自定义的sql执行，需要对sql语法了解才能灵活运用
s sqlx = "insert into info (url,filename,status) values ('http://abc.com/abc.apk', 'abc.apk', 1)"
s sjk17 = sjk.cxsj(sqlx)


注意：
在执行sql语句的时候，需要注意你的字符串的特殊字符的转义。
     /   ->    //
     '   ->    ''
     [   ->    /[
     ]   ->    /]
     %   ->    /%
     &   ->    /&
     _   ->    /_
     (   ->    /(
     )   ->    /)

【sj.md5 获取MD5吗】
用法：

// 输入 File对象，获取文件的md5
// 获取文件对象
s f1 = wj.wj("%a.txt")
// 根据文件对象获取md5
s b1 = sj.md5(f1)
gj.sc(b1)

// 输入byte[] 获取字节数组的md5
// 获取文件的byte[]字节数组
s f2 = wj.zjsz("%a.txt")
// 根据字节数组来获取md5
s b2 = sj.md5(f2)
gj.sc(b2)

// 输入字符串 获取字节数组的md5
// 根据字节数组来获取md5
s b3 = sj.md5("abcdef")
gj.sc(b3)


【动画操作】
用法：

// 创建动画对象
s dh = gj.dh()

// 渐变透明度动画，1 代表不透明，0代表透明；还可以设置0.5等半透明
s jbtm = dh.jbtm(1, 0)
// 持续时长
jbtm.cxsc(2000)
// 设置控件执行动画
st.tx(zy.i.tx1).dh(jbtm)



//创建一个渐变尺寸伸缩动画
//0为没有，2.5为原始2.5倍
s jbss = dh.jbss(0.5, 2.5, 0.5, 2.5)
// 持续时长
jbss.cxsc(2000)
// 设置控件执行动画
st.tx(zy.i.tx1).dh(jbss)

位置类型：
0 默认
1 以对象本身为基准位置类型
2 以父控件为基准位置类型

//输入X开始尺寸比例，输入X结束尺寸比例，输入Y开始尺寸比例，输入Y结束尺寸比例，输入X位置类型，输入X坐标的开始位置，输入Y位置类型，输入Y坐标的开始位置
s jbss2 = dh.jbss(0.5, 2.5, 0.5, 2.5, 1, 0.5, 1, 0.5)
// 持续时长
jbss2.cxsc(2000)
// 设置控件执行动画
st.tx(zy.i.tx1).dh(jbss2)



//创建一个画面位置移动动画
//输入开始X坐标上的移动位置，结束X坐标上的移动位置，开始Y坐标上的移动位置，结束Y坐标上的移动位置
s wzyd = dh.wzyd(30, 80, 30, 80)
// 持续时长
wzyd.cxsc(2000)
// 设置控件执行动画
st.tx(zy.i.tx1).dh(wzyd)



//创建一个画面旋转动画
//输入动画开始的旋转角度，输入动画旋转到的角度
s xz = dh.xz(0, 180)
// 持续时长
xz.cxsc(2000)
// 设置控件执行动画
st.tx(zy.i.tx1).dh(xz)

位置类型：
0 默认
1 以对象本身为基准位置类型
2 以父控件为基准位置类型

//输入动画开始的旋转角度，输入动画旋转到的角度，输入X位置类型，输入X坐标的开始位置，输入Y位置类型，输入Y坐标的开始位置
s xz = dh.xz(0, 180, 1, 0.5, 1, 0.5)
// 持续时长
xz.cxsc(2000)
// 设置控件执行动画
st.tx(zy.i.tx1).dh(xz)




// 开始使用 动画集合
s jh = dh.jh(false)

// 渐变透明度动画
s jbtm = dh.jbtm(1, 0)
// 持续时长
jbtm.cxsc(2000)
jh.tj(jbtm)

//渐变尺寸伸缩动画
s jbss = dh.jbss(0.5, 2.5, 0.5, 2.5)
// 持续时长
jbss.cxsc(2000)
jh.tj(jbss)

//画面位置移动动画
s wzyd = dh.wzyd(30, 80, 30, 80)
// 持续时长
wzyd.cxsc(2000)
jh.tj(wzyd)

//画面旋转动画
s xz = dh.xz(0, 180)
// 持续时长
xz.cxsc(2000)
jh.tj(xz)

// 添加动画集合完毕后执行这个动画集合
// 设置控件执行动画
st.tx(zy.i.tx1).dh(jh)

说明：
常用于动画集合执行。

提示：
动画集合允许被其他动画集合添加成为子动画。

提示：
动画集合如果设置了动画控制属性，同时也会重置所有子控件的属性。





// 开始使用 动画队列执行

//旋转动画
//输入控件ID或控件对象，输入动画类型，输入旋转角度数组...（可输入N个参数）
s sz = { 60, 180 }
s xz = dh.dl(zy.i.tx1, "rotation", sz)
//s sz2 = { 30, 80, 60, 20, 60 }
//dh.dl(zy.i.tx1, "rotationX", sz2)
//s sz3 = { 30, 80 }
//dh.dl(zy.i.tx1, "rotationY", sz3)
// 持续时长
xz.cxsc(2000)
// 开始
xz.ks()


//伸缩动画
//输入控件ID或控件对象，输入动画类型，输入伸缩尺寸比例数组...（可输入N个参数）
s sz4 = { 1.5, 2.5 }
s ssdh = dh.dl(zy.i.tx1, "scaleX", sz4)
//s sz5 = { 1.5, 2.5, 1.2, 2.6, 1.3 }
//dh.dl(zy.i.tx1, "scaleY", sz5)
// 持续时长
ssdh.cxsc(2000)
// 开始
ssdh.ks()


//移动动画
//输入控件ID或控件对象，输入动画类型，输入移动到位置数组...（可输入N个参数）
s sz6 = { 0, 60 }
s yddh = dh.dl(zy.i.tx1, "translationX", sz6)
//s sz7 = { 0, 60, 30, 10, 60 }
//dh.dl(zy.i.tx1, "translationY", sz7)
// 持续时长
yddh.cxsc(2000)
// 开始
yddh.ks()



//透明度
//输入控件ID或控件对象，输入动画类型，可见度比例数组(0.0至1.0)...（可输入N个参数）
s sz8 = { 1, 0.3, 1, 0.2, 1 }
s tm = dh.dl(zy.i.tx1, "alpha", sz8)
// 持续时长
tm.cxsc(2000)
// 开始
tm.ks()



// 开始使用 队列动画集合

//旋转动画
s sz9 = { 60, 180 }
s xz = dh.dl(zy.i.tx1, "rotation", sz9)
// 持续时长
xz.cxsc(2000)

//伸缩动画
s sz10 = { 1.5, 2.5 }
s ssdh = dh.dl(zy.i.tx1, "scaleX", sz10)
// 持续时长
ssdh.cxsc(2000)

//移动动画
s sz11 = { 0, 60 }
s yddh = dh.dl(zy.i.tx1, "translationX", sz11)
// 持续时长
yddh.cxsc(2000)

//透明度
s sz12 = { 1, 0.3, 1, 0.2, 1 }
s tm = dh.dl(zy.i.tx1, "alpha", sz12)
// 持续时长
tm.cxsc(2000)

// 设置数组
s sz = { xz, ssdh, yddh, tm }


//队列顺序执行
s dlsx = dh.dlsx(sz)

//队列同时执行
s dlts = dh.dlts(sz)
//dlts.ks()

// 开始执行动画
dlsx.ks()

说明：
常用于动画集合执行。

提示：
队列动画集合允许被其他队列动画集合添加成为子动画。

提示：
动画集合如果设置了动画控制属性，同时也会重置所有子控件的属性。


// 开始使用 动画控制

// 位置移动动画
s wzyd = dh.wzyd(30, 80, 30, 80)

// 取消
wzyd.qx()

// 重置属性
wzyd.cz()

// 开始
wzyd.ks()

// 持续时长
wzyd.cxsc(2000)

// 延迟执行
wzyd.yczx(1000)

// 启用动画结束填充效果
wzyd.qytc(true)

// 动画执行后，控件停留执行结束状态
wzyd.tljszt(true)

// 动画执行后，控件停留执行开始状态
wzyd.tlkszt(true)

// 动画重复执行的次数
wzyd.cfzx(6)

// 动画集合添加动画，仅用于动画集合
s jh = dh.jh(false)
jh.tj(wzyd)

// 动画监听事件
jh.dhsj
{
//当结束动画时
gj.sc("End")
},
{
//当重复动画时
gj.sc("Repeat")
},
{
//当启动动画时
gj.sc("Start")
}


s sz9 = { 60, 180 }
// 旋转动画
s xz = dh.dl(zy.i.tx1, "rotation", sz9)

// 取消
xz.qx()

// 开始
xz.ks()

// 持续时长
xz.cxsc(2000)

// 延迟执行
xz.yczx(1000)

// 是否正在运行
s zzyx = xz.zzyx()

// 设置动画执行的控件
xz.kj(zy.i.tx1)

// 克隆动画
s kl = xz.kl()


// 动画监听事件
xz.dhjtsj{
//当结束动画时
gj.sc("End")
},
{
//当重复动画时
gj.sc("Repeat")
},
{
//当启动动画时
gj.sc("Start")
},
{
//当取消动画时
gj.sc("Cancel")
}



// 开始使用 动画背景
//创建动画背景
//输入是否重复执行
s dhbj = dh.dhbj(true)

//添加元素
//输入背景图像或图片变量或背景对象，输入显示时长
dhbj.tj("@t1.png", 1000)
dhbj.tj("%t2.png", 1000)
dhbj.tj(zy.t.t3, 1000)

//设为指定控件背景
st.tx(zy.i.tx1).bj(dhbj)

//开始动画
dhbj.ks()

//停止动画
dhbj.tz()

//是否在运行
s zzyx = dhbj.zzyx()


【zf.json json数据解析】
用法：

//解析json数据
s text = "{\"id\":1, \"name\":\"xiaobai\", \"age\":16}"
s jo = zf.json(text)

// 获取根json对象
s json = jo.json

//获取id
s id = jo.hq(json, "id")

//获取name
s name = jo.hq(json, "name")

//获取age
s age = jo.hq(json, "age")

//修改age数据
jo.sz(json, "age", 20)

//删除id数据
s sc = jo.sc(json, "id")

//打印json数据
s text = jo.json(json)



//解析json列表数据
s text = "{\"userlist\":[{\"id\":1, \"name\":\"niubi\", \"age\":16},{\"id\":2, \"name\":\"wangba\", \"age\":18},{\"id\":3, \"name\":\"goudan\", \"age\":17}]}"
s jo = zf.json(text)

// 获取根json对象
s json = jo.json

//获取json对象列表
s list = jo.dxlb(json, "userlist")
// 获取列表的长度
s size = jo.cd(list)
xh size > 0
{
size = size - 1
s dx = jo.dx(list, size)

//获取id
s id = jo.hq(dx, "id")

//获取name
s name = jo.hq(dx, "name")

//获取age
s age = jo.hq(dx, "age")

}

【utb Toolbar工具栏设置】
用法：

//设置自定义的工具栏 为当前界面的工具栏
//输入Toolbar工具栏的 控件id或控件对象
s gjl = st.gjlbj(zy.i.gjlbj1).gjl()

// 设置左按钮可用
gjl.zanky(true)

// 设置左按钮是否显示
gjl.zanxs(true)

// 设置左按钮为小箭头
gjl.zanxjt(true)

// 设置左按钮图像
gjl.zantx("@t1.png")
//gjl.zantx(zy.t.tp1)

// 设置左按钮监听事件
gjl.zanjtsj{
gj.sc("左按钮监听事件")
}

// 设置右按钮图像，无事件。可使用界面菜单事件
gjl.yantx("@t1.png")
//gjl.yantx(zy.t.tp1)

//显示或隐藏 自定义布局
gjl.xszdybj(true)

//显示或隐藏 标题
gjl.xsbt(true)

//获取高度
s g = gjl.g()

//设置显示选项
gjl.xsxx(2)
//获取显示选项
s xsxx = gjl.xsxx()


//设置自定义布局
// 新建一个控件
s wb1 = st.wb();
wb1.kg(-1, -2);
gjl.zdybj(wb1)
//获取自定义布局
s zdybj = gjl.zdybj()

//设置标题
gjl.bt("这是标题")
//获取标题
s bt = gjl.bt()

//设置子标题
gjl.zbt("这是子标题")
//获取子标题
s bt = gjl.zbt()


【st.tctx 弹窗提醒】
用法：
//无按钮弹出提醒
//输入控件对象或ID，输入字符，输入显示时长（值0 -1 -2）
st.tctx(zy.i.xxbj1, "ni hao!", 0)


//有按钮弹出提醒
//输入控件对象可设置null，输入字符，输入显示时长（值0 -1 -2），输入按钮标题
st.tctx(zy.i.xxbj1, "ni hao ma?", 0, "OK")
{
gj.sc("go")
}

//有按钮弹出提醒
//输入控件对象可设置null，输入字符，输入显示时长（值0 -1 -2），输入按钮标题，颜色
st.tctx(zy.i.xxbj1, "ni hao ma?", 0, "OK", "#000000")
{
gj.sc("go")
}


【滑动窗体控制】
用法：

// 获取滑动窗体
s hdct1 = st.hdct(zy.i.hdct1)

//绑定标签布局，绑定后滑动界面时标签布局会跟随运动，需要注意 标签布局 和 滑动窗体 的子项数量应一致，新增子项时也需要同时增加
//输入标签布局的 控件id或控件对象，是否应刷新其内容
s bdbqbj = hdct1.bdbqbj(zy.i.bqbj1, true)
//注意：如果绑定前 标签布局 如有设置子项，绑定时会被清空。绑定后直接添加滑动窗体 的子项并设置 标题


// 获取标签布局
s hdct1 = st.bqbj(zy.i.bqbj1)

// 加标签
hdct1.jbq("选项")



// 获取页面管理
s ym1 = hdct1.ym()


//添加新的页面，设置的界面会执行载入事件里的代码
//输入插入序号 如-1为尾部 0为头部，输入标题，输入界面类，输入布局资源，输入控件ID或数据ID，输入数据内容
s ids = { zy.i.wb1, zy.i.wb2, zy.i.wb3 }
s values = { "abc", "bac", "bbc" }
ym1.j(-1, "标题", a.lei, zy.b.a, ids, values)


//删除界面
//输入滑动窗体的 控件id或控件对象，输入标识，输入界面序号 序号以0开始 -1为尾部
ym1.sc(0)


//修改界面标题
//输入滑动窗体的 控件id或控件对象，输入标识，输入界面序号 序号以0开始 -1为尾部
ym1.xg(0, "标题2")


//获取页面数量
s ymsl = ym1.ymsl()

//释放内存
ym1.sf()


// 其中列表的项目所用的布局是界面 a.iyu 上面的布局，并且布局控件可以设置事件。

// 在其事件中获取相关列表适配器数据

// 如 a.iyu界面中 ID zy.i.wb1 的控件 的 单击触屏事件 进行 页面数据的操作


// 页面数据的操作
s lb2 = sj.lb(vw)

// 获取触发控件的位置
s lbcfwz = lb2.lbcfwz()

// 获取触发控件的数据对象
s lbcfsj = lb2.lbcfsj()

// 获取指定ID的对应数据
s lbcfsj2 = lb2.lbcfsj(zy.i.wb1)

// 获取指定位置 和 指定ID的对应数据
s lbsj1 = lb2.lbsj(0, zy.i.wb1)

// 获取指定位置数据对象
s lbsj2 = lb2.lbsj(0)

// 获取列表数据对象
s lbsj3 = lb2.lbsj()

// 获取项目根视图控件
s lbxmst = lb2.lbxmst()


【st.tccd 弹出菜单】
用法：

// 代码自定义菜单
// 输入菜单绑定的控件对象或ID
s tccd = st.tccd(zy.i.xxbj1)(mi){

// 触发选择后
s id = mi.getItemId()
rg id == 0{
// 选择了 选项1
gj.sc("选项1")

}, id == 1{
// 选择了 选项2
gj.sc("选项2")

}
// 该回调有返回值 为布尔类型；注意一定要设置一个返回值
fh fou
}
// 获取菜单对象
s menu = tccd.getMenu()
// 添加菜单
menu.add(0, 0, 0, "选项1")
menu.add(1, 1, 1, "选项2")
// 弹出菜单
tccd.show()


// 使用xml载入菜单
// 输入是否默认弹出菜单，输入菜单绑定的控件对象或ID，输入菜单的XML对应ID
s tccd = st.tccd(true, zy.i.xxbj1, zy.menu.caidan)(mi){

// 触发选择后
s id = mi.getItemId()
rg id == 0{
// 选择了 选项1
gj.sc("选项1")

}, id == 1{
// 选择了 选项2
gj.sc("选项2")

}
// 该回调有返回值 为布尔类型；注意一定要设置一个返回值
fh fou
}


// 使用数组创建菜单
s ids = { 0, 1 }
s names = { "选项1", "选项2" }

// 输入是否默认弹出菜单，输入菜单绑定的控件对象或ID，输入菜单ID数组，输入菜单标题数组
s tccd = st.tccd(true, zy.i.xxbj1, ids, names)(mi){

// 触发选择后
s id = mi.getItemId()
rg id == 0{
// 选择了 选项1
gj.sc("选项1")

}, id == 1{
// 选择了 选项2
gj.sc("选项2")

}
// 该回调有返回值 为布尔类型；注意一定要设置一个返回值
fh fou
}


【动态设置事件】
用法：

// 获取一个编辑框控件对象
s bjk = st.bjk(zy.i.bjk1)

// 下面以编辑框控件对象为例，动态设置常用监听事件

// ---  动态设置单击触屏事件 --- 
// 简易写法
bjk.sj.dj{
gj.sc("单击")
}
或
bjk.sj.dj(){
gj.sc("单击")
}

// 定义参数
bjk.sj.dj()(vw){
gj.sc("单击，参数一：" + vw)
}

// ---  动态设置触屏监听事件 --- 
bjk.sj.cp(){
gj.sc("触屏")
// 需要返回一个boolean值
fh fou
}

// 定义参数
bjk.sj.cp()(vw,me){
gj.sc("触屏，参数一：" + vw + "  参数二：" + me)
// 需要返回一个boolean值
fh fou
}

// ---  动态设置触屏长按事件 --- 
bjk.sj.cpca(){
gj.sc("触屏长按")
// 需要返回一个boolean值
fh fou
}

// 定义参数
bjk.sj.cpca()(vw){
gj.sc("单击，参数一：" + vw)
// 需要返回一个boolean值
fh fou
}

// ---  动态设置键盘触发事件 --- 
bjk.sj.jpcf(){
gj.sc("键盘触发")
// 需要返回一个boolean值
fh fou
}

// 定义参数
bjk.sj.jpcf()(vw,kc,et){
gj.sc("键盘触发，参数一：" + vw + "  参数二：" + kc + "  参数三：" + et)
// 需要返回一个boolean值
fh fou
}

// ---  动态设置获得焦点事件 --- 
bjk.sj.hdjd(){
gj.sc("获得焦点")
}

// 定义参数
bjk.sj.hdjd()(vw,hf){
gj.sc("获得焦点，参数一：" + vw + "  参数二：" + hf)
}

// ---  动态设置编辑框监听 --- 
bjk.sj.bjkjt(){
gj.sc("编辑框监听")
// 需要返回一个boolean值
fh fou
}

// 定义参数
bjk.sj.bjkjt()(vw,ad,et){
gj.sc("编辑框监听，参数一：" + vw + "  参数二：" + ad + "  参数三：" + et)
// 需要返回一个boolean值
fh fou
}

// ---  动态设置文本更新监听事件 --- 
bjk.sj.wbgx(){
gj.sc("文本改变")
}, {
gj.sc("文本改变之前")
}, {
gj.sc("文本改变之后")
}

// 定义参数
bjk.sj.wbgx()(cs,sr,be,ct){
gj.sc("文本改变，参数一：" + cs + "  参数二：" + sr + "  参数三：" + be + "  参数四：" + ct)
}, (cs,sr,ct,ar){
gj.sc("文本改变之前，参数一：" + cs + "  参数二：" + sr + "  参数三：" + ct + "  参数四：" + ar)
}, (ee){
gj.sc("文本改变之后，参数一：" + ee)
}

【自定义控件】
新增控件：在 添加控件 滑动到底部，点击 添加新控件
例，输入：
控件名：线性的控件
完整类名：android.widget.LinearLayout

代码相关操作：
// 根据控件ID 来获取自定义控件对象
android.widget.LinearLayout xxbj = st.st(zy.i.v1)

// 获取到对象后，就可以调用该控件的方法等等操作
xxbj.xxx()
s abc = xxbj.xxx
...


【更多代码正在测试中，会逐步开放！】
