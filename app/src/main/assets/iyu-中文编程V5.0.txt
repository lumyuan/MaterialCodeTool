iApp【指定系统编译】

[方案一]

// 在裕语言V5中可以指定系统来编译代码

//执行 java 多行代码
java
{
  string sts = "这是 iApp";
  android.util.Log.v("iapp", sts);

}

//执行 java 单行代码
java android.util.Log.v("iapp", "这是 iApp");


[方案二]

// 裕语言V5 允许java 格式文件，进行混编交互。

// 创建 *.java 文件 并且完全支持 android 原生开发。


【目录开头符号标识】

// 代码中需要输入一个文件的代码，填写路径的开头第一个可以使用符号进行快捷指向路径

// 路径开头为 % 硬盘分区根路径

// 路径开头为 @ 包内资源路径

// 路径开头为 $ 应用安装位置路径


【裕语言v5 里的根对象】

用法：

//这是裕语言V5里的根对象，也是所有子对象的父对象，裕语言V5 所有代码的源头命名。
iapp


//------- 根对象的 子对象

// 字符管理对象
iapp.字符

// 数据管理对象
iapp.数据

// 视图管理对象
iapp.视图

// 文件管理对象
iapp.文件

// 工具管理对象
iapp.工具

// 网络管理对象
iapp.网络

// 系统管理对象
iapp.系统

//前缀 iapp 是根对象的，也可以直接写它的子对象

如：
// 工具对象 里的 输出方法
工具.输出("输出文字")


//------- 根对象的 方法

// 为了更简便的使用常用方法，根对象提供以下方法：

// 输出
iapp.工具.输出(123) 可直接使用 工具.输出(123)

【资源管理对象】
// 资源管理对象，与代码根对象不同，主要的作用是获取项目内相关资源的ID
// 资源管理对象的 根对象
资源 或 iapp.资源


// 获取 strings.xml 内的名称为 a 字符串
是 a = 字符.字符(资源.字串.a)

// 获取 drawable 内的文件名为 b.xml 的文件，常用于背景的绘制
是 b = 数据.绘制(资源.绘制.b)

// 获取 mipmap 内的文件名为 c.png 的图像资源ID（一个整数），可将ID设置给图像控件、图像按钮控件等
是 c = 资源.图像.c

// 获取控件的ID
是 d = zy.id.wb1
//或
//是 d = 资源.编号.wb1


【类模块对象的创建】

// myu 类模块需要先创建对象
创建 或  iapp.创建

// 创建 abc.myu 类模块的对象，同时会调用 abc.myu 类模块的构造 方法 lei()
是 abc = 创建.abc()

// 调用类模块的变量
是 b = abc.b

// 调用类模块的方法
是 c = abc.c()


// 也可以用于数组对象的创建，创建一个长度为 10 的字符串数组
string[] sz = 创建.string[10]


【修饰符】

// 全局；在变量或 方法前加上后可使用 文件名.方法或变量名 进行访问。
全局

// 私有；在变量或 方法前加上后，方法或变量名仅供当前文件访问。
私有

// 固定；申明 变量 并赋值后，其值不可改变。其变量可在方法内任意代码块里调用，如下
固定

// 固定 例1
方法 a()
{

固定 是 abc = "abc"

// 创建线程
工具.线程(){

工具.输出(abc)

}

}

【自定义application】
在 AndroidManifest.xml 中自定义 application name 类一定要 extends i.app.applicationMain

【是 数据类型】

用法：

// 推断类型

//说明：根据首次赋值的数据来推断变量类型。推断类型 无法作为方法的申明参数变量使用。


// 字符串型（String）
是 d = "nihao"
字串 d2 = "nihao"
string d2 = "nihao"


// 整数型（int）
是 e = 123
整数 e2 = 123
int e2 = 123


// 小数型（double）
是 f = 123.123
小数 f2 = 123.123
双精小数 f2 = 123.123
double f2 = 123.123


// 是否型（boolean）
是 g = shi
是否 g2 = 否
boolean g2 = fou
//可以这写
//s g = true
//boolean g2 = false


// 数据型（Object）
是 h = kong
object h = null

//可以这写，不赋值。注意：变量默认值不为 kong 
//s h
//object h


// 方法参数变量需要指向性数据类型

方法，例：

方法 jyg(s bl = 0)
{
返回 bl + 1
}

// 全局变量：需要写在类模块里，并且不能写在方法内，应该写在方法外；

// 1. 在 类模块 里申明的变量；可以在该类中的所有方法 或 事件方法 内使用；
是 abc = 1

// 增加全局修饰符
全局 是 abc2 = 2

【myu 类模块】
// 创建一个 abc.myu 源码文件，内容如下：

// 创建 模块变量 a并赋值
是 a = "NiHao"
是 aa = ""
全局 是 aaa = "全局变量"

// 用java申明变量
java int abc1 = 100

java public int abc5 = 200

// 用java写方法
java
{
  public void abc2(int abc22)
  {
    abc1 = abc22;
  }

  public int abc3(int abc33)
  {
    return abc1 + abc33 + 100;
  }
}

// 构造方法
方法 lei(s a = "")
{
aa = a
}

// 创建方法 b
方法 是 b()
{
  返回 a
}

// 创建方法 c
方法 是 c(s d = "")
{
  返回 a + d + aa
}

// ----- 调用实例 -----

// 创建对象
是 abc = 创建.abc("hahaha")

// 输出 模块变量 aa
工具.输出(abc.aa)

// 输出 模块方法 b
工具.输出(abc.b())

// 输出 模块方法 c
工具.输出(abc.c("Ma?"))

// 输出 全局变量
工具.输出(abc.aaa)

// 调用java写的方法
java abc.abc2(123)

// 调用java写的方法
java gj.sc(abc.abc3(567))

// 获取java申明的变量
java gj.sc(abc.abc5)


【ff 方法】

// 以 方法 开头 + [可选：修饰符] + [可选：方法返回类型] + 方法名 ( 参数 [可选：强制参数类型] )
方法 abc()
{
  工具.输出("这是 无返回数据，无参数 的方法")
}


// 返回 为 返回数据的代码

// 返回如设置 是 将等同于Object类型
方法 是 abc(s a)
{
  工具.输出("这是 返回数据a + 123，参数变量a将等同于Object类型 的方法")
  返回 a + 123
}

// 返回如设置 int 为整数类型
方法 int abc(s a = 0)
{
  工具.输出("这是 返回数据a + 123，参数变量a预设值为整数0将 是 类型强制转换为 int 的方法")
  返回 a + 123
}


// 修饰符 全局 为全局方法，其他界面 与 模块 里可以调用
// 返回如设置 int 为整数类型
全局 方法 int abc(int a)
{
  工具.输出("这是 返回数据a + 123，参数变量a类型为 int 的方法")
  返回 a + 123
}


【数组类型】
用法：

// 申明一个字符串数组
s sz1 = { "abc", "def", "g" }
// 申明一个字符串数组
string[] sz4 = { "abc", "def", "g" }

// 获取数组长度
s cd = sz1.length

// 申明一个字符串数组
s sz2 = cj.string[3]
// 给数组赋值
sz2[0] = "abc"
sz2[1] = "def"
sz2[2] = "g"

// 读取数组内容
s a1 = sz2[0]

// 申明一个类模块数组，提前创建一个类模块 mk.myu
// 初始化模块
s mk1 = cj.mk()
s mk2 = cj.mk()
// 创建类模块数组
s sz3 = { mk1, mk2 }

// 创建类模块数组
s sz5 = cj.mk[2]
sz5[0] = mk1
sz5[1] = mk2

// 循环数组
xh s q1, sz1
{
gj.sc(q1)
}

xh s q2, sz5
{
gj.sc(q2)
}


【数组列表类型】
用法：

// 申明一个字符串的数组列表
alist<string> lb1 = cj.alist<string>()

// 申明一个类模块的数组列表，提前创建一个类模块 mk.myu
alist<mk> lb2 = cj.alist<mk>()

// 添加数据
s q2 = "abc";
lb1.add(q2)
// 指定序号位置添加数据， 序号是从0开始
lb1.add(0, "bc")

// 指定序号位置修改数据
lb1.set(0, "bcbc")

// 获取数组列表长度
s cd = lb1.size()

// 获取数据
s q1 = lb1.get(0)

// 获取是否存在数据
s cz = lb1.contains(q2)

// 获取数据在列表中的序号，从开始位置向后查找，序号是从0开始
s x1 = lb1.indexOf(q2)

// 获取数据在列表中的序号，从结束位置向前查找，序号是从0开始
s x2 = lb1.lastIndexOf(q2)

// 删除数据
lb1.remove(0)
// 删除数据 或输入数据对象
lb1.remove(q2)
// 删除所有数据
lb1.clear()

// 循环数组列表
xh s q3, lb1
{
gj.sc(q3)
}


【哈希表类型】
用法：

// 申明一个字符串的数组列表
hmap<string, string> map1 = cj.hmap<string, string>()

// 申明一个类模块的数组列表，提前创建一个类模块 mk.myu
hmap<string, mk> map2 = cj.hmap<string, mk>()

// 添加数据
s q2 = "abc";
// 指定 键名 添加或修改 数据
map1.put("a", "bcc")
map1.put("b", q2)

// 获取哈希表长度
s cd = map1.size()

// 指定 键名 获取数据
s q1 = map1.get("a")

// 获取指定 键名 是否存在
s cz = map1.containsKey("a")

// 获取指定 数据对象 是否存在
s cz2 = map1.containsValue(q2)

// 指定 键名 删除数据
map1.remove("a")

// 指定 键名 和 键值 删除数据，需要 键名 和 键值 匹配后删除
map1.remove("b", q2)

// 删除所有数据
map1.clear()

// 循环 键名
s sz2 = map1.keySet()
xh s x2, sz2
{
  gj.sc(x2)
}

// 循环 键值
s sz = map1.values()
xh s x1, sz
{
  gj.sc(x1)
}

【// 或 /* */ 注释】

用法：

//单行注释

/*
这是多行注释
*/


【工具.输出 输出】
用法：

// 可以输出数据
工具.输出("1314")

【如果 如果判断】
用法：

是 a = 2
如果 a == 1
{
	工具.输出("等于1")
}
,a == 2
{
	工具.输出("等于2")
}
,
{
	工具.输出("等于其他")
}

支持运算符（返回 是 与 否）：
== 是否对等
!= 是否不等于
>= 是否大于或等于
<= 是否小于或等于
> 是否大于
< 是否小于
?* 字符串开头是否相同
*? 字符串结尾是否相同
? 字符串是否被包含
上面三个举例：
是 a = "abcdef"
如果 a ?* "abc" 返回“是”
如果 a *? "def" 返回“是”
如果 a ? "cde" 返回“是”

支持逻辑运算符：
|| 或者
&& 并且

【循环 循环】
用法：
//这将循环99次
是 a = 99
// 单个表达式循环
循环 a > 0
{
工具.输出(a)
a = a - 1
}

//这将循环9次，使用 a-- 让变量每次减少1
是 a = 9
// 单个表达式循环
循环 a > 0
{
工具.输出(a)
a--
}

//这将循环9次，使用 a++ 让变量每次增加1
是 a = 0
// 单个表达式循环
循环 a < 9
{
工具.输出(a)
a++
}

// 循环扩展2
是 sz = { "a", "b", "c", "d" }
// 2个表达式的循环
循环 是 i, sz
{
工具.输出(i)
}


// 循环扩展3
是 a = 9
// 3个表达式的循环
循环 是 i=0, i<a, i++
{
工具.输出(i)
}

// 跳出循环  将直接跳出循环
是 a = 9
// 3个表达式的循环
循环 是 i=0, i<a, i++
{
  如果 i>3{
    跳出循环 
  }
工具.输出(i)
}

// 跳出本次循环  将直接跳出本次循环，并继续执行后面的循环
是 a = 9
// 3个表达式的循环
循环 是 i=0, i<a, i++
{
  如果 i>3{
    跳出本次循环 
  }
工具.输出(i)
}

说明：
条件循环语句，比较值的变化，然后进行循环执行 { 代码 } 里面的代码。当条件为“否”的时候会停止循环，条件“是”的话，将一直循环执行。
支持运算符（返回 是 与 否）：（跟 如果 语句 一样，请参考）

【异常 异常】

// 无异常日志
异常{
工具.输出("执行正常代码")

},{

工具.输出("如果发生异常，将被执行")

}

// 有异常日志
异常{
工具.输出("被执行代码")

},(e){

工具.输出("如果被执行代码发生异常，将被执行；异常日志:" + e)

}

说明：
常用于可能发生异常代码的执行，其中的代码如果发生了异常不会造成应用崩溃。

【视图.*() 获取视图控件】
用法：

//如，获取文本控件对象
// 输入控件的ID
是 wb = 视图.文本(zy.id.wb1)
工具.输出(wb)


是 wb2 = 视图.文本(zy.id.wb2)
// 获取控件的原对象 返回 TextView类型
工具.输出(wb2.st)

// 获取文本控件的文本字符
工具.输出(wb2.zf())


// 设置文本控件的文本字符
wb2.zf("ni hao ma?")

// 其他所有控件获取方法是一样的，获取的对象 子方法可能有差别。

// 获取线性布局对象
// 输入控件的ID
是 xxbj = 视图.线性布局(zy.id.xxbj1)
工具.输出(xxbj)


// 获取视图对象，获取的是View对象
// 获取wb1视图对象
是 wb1 = 视图.视图(zy.id.wb1)

// 根据 xxbj1对象来获取其中的 wb2 的视图对象
是 xxbj1 = 视图.视图(zy.id.xxbj1)
是 wb2 = 视图.视图(xxbj1, zy.id.wb2)


【工具.线程 新线程】
用法：
工具.线程()
{
	工具.输出("新线程里执行代码")
}

说明：
启用新线程，去执行一些需要执行很久的代码。比如把下载文件，获取网页源码，大量的文件操作，可以放入新线里执行。这里线程的概念，启用新的线程帮你处理代码，这样不会影响到主线程。


【工具.界面线程 界面线程上运行】
用法：
// 对应V3.0 线程更新界面

工具.界面线程()
{
	工具.输出("界面线程上运行代码")
}



// 界面线程 上对视图进行操作

// 启用一个新线程
工具.线程()
{
// 这里可以执行耗时间的数据处理

// 然后需要更新视图控件时，需要在界面线程上面执行，否则将报错
工具.界面线程()
{
  是 wb2 = 视图.文本(zy.id.wb2)
  // 设置文本控件的文本字符
  wb2.zf("ni hao ma?")
}

}


说明：
在启用新线程去执行代码时，是不允许直接对视图进行更新。视图控件需要在界面线程上更新，否则将报错；


【工具.提示 提示】
用法：

// 该方法需要手机开放应用的通知权限

// 第一个参数为 需要被提示的内容
工具.提示("你好")

// 或 第二个参数为显示时长 1代表正常，2代表短暂
工具.提示("你好", 1)


【文件.文件 获得文件对象】
用法：
// 获取文件对象
是 f = 文件.文件("%a.txt")
// 输出完整文件路径
工具.输出(f.getAbsolutePath())


【文件.存在 文件是否存在】
用法：
// 文件是否存在
是 a = "%abc.zip"
是 b = 文件.存在(a)

// 文件夹是否存在
是 a = "%abc"
是 b = 文件.存在(a)

//返回 true 或 false
工具.输出(b)

【文件.删除 删除文件】
用法：
// 删除文件
是 a = "%abc.zip"
是 b = 文件.删除(a)

// 文件夹删除，并删除子文件夹
是 a = "%abc"
是 b = 文件.删除(a, true)

//返回 删除文件的数量
工具.输出(b)

【文件.大小 文件大小】
用法：
是 a = "%abc.zip"
是 b = 文件.大小(a)

//返回 文件 或 文件夹 的大小
工具.输出(b)

【文件.读取文本 读取文本】
用法：(将读取SD卡根目录的abc.txt文件里面的内容)
是 a = "%abc.txt"
是 c = 文件.读取文本(a)

是 a = "%abc.txt"
是 b = "utf-8"
是 c = 文件.读取文本(a, b)

//返回 文本文件 的内容
工具.输出(b)

【文件.写入文本 写入文本】
用法：(将文本数据写入至SD卡根目录的abc.txt文件里面)
是 a = "%abc.txt"
是 b = "我是一个txt文件的内容"
是 d = 文件.写入文本(a, b)

是 a = "%abc.txt"
是 b = "我是一个txt文件的内容"
是 c = "utf-8"
是 d = 文件.写入文本(a, b, c)

//返回 true 或 false
工具.输出(d)


【文件.复制 复制文件】
用法：
是 a = "%abc.txt"
是 b = "%abc2.txt"
是 d = 文件.复制(a, b)

//设置重复不覆盖
是 c = false
是 d = 文件.复制(a, b, c)

//返回 true 或 false
工具.输出(d)


【文件.列表 文件夹与文件列表】
用法：

// 注意 lb l是字母L的小写， 为拼音首字母 lb=列表

是 a = "%dir"

//获取文件夹与文件列表
是 b = 文件.列表(a)
// 循环数组
循环 是 c, b
{
  工具.输出(c)
}

//仅获取文件夹列表
是 a = "%dir"
是 b = 文件.列表(a, true)
// 循环数组
循环 是 c, b
{
  工具.输出(c)
}

//仅获取文件列表
是 a = "%dir"
是 b = 文件.列表(a, false)
// 循环数组
循环 是 c, b
{
  工具.输出(c)
}


【文件.查找文件 查找文件】
用法：

// 文件名过滤，开头与结尾的*为任意字符
是 gl = { "*.txt", "abc", "abc*" }

// 获取一个 File[] 对象数组
是 lb = 文件.查找文件("%dir", gl)

// 循环打印
循环 是 c, lb
{
  工具.输出(c.getAbsolutePath())
}


【文件.转移 转移文件】
用法：
是 a = "%abc.txt"
是 b = "%abc2.txt"
是 d = 文件.转移(a, b)

//设置重复不覆盖
是 c = false
是 d = 文件.转移(a, b, c)

//返回 true 或 false
工具.输出(d)


【文件.获取目录 获取目录路径】
用法：

是 a = "%dir"
是 d = 文件.获取目录(a)

//返回 绝对路径
工具.输出(d)

【文件.解压 解压zip文件】
用法：

// 目标ZIP
是 a = "%a.zip"
// 只解压部分文件
是 b = "b.txt"
// 解压到指定目录
是 c = "%dir"
// 重复是否覆盖
是 d = true

// 解压指定部分文件文件，并指定重复覆盖
是 e = 文件.解压(a, b, c, d)

//返回 解压文件数量
工具.输出(e)

// 解压文件，并指定重复覆盖
是 e = 文件.解压(a, c, d)
//返回 解压文件数量
工具.输出(e)

// 解压文件，重复不覆盖
是 e = 文件.解压(a, c)
//返回 解压文件数量
工具.输出(e)


【文件.压缩 压缩zip文件】
用法：

// 目标文件夹路径
是 a = "%dir"

// 压缩到ZIP的路径
是 b = "%a.zip"

// 解压文件，重复不覆盖
是 d = 文件.压缩(a, b)

//返回 压缩的文件数量
工具.输出(d)


【文件.打开 打开文件】
用法：
是 a = "%abc.apk"
文件.打开(a)

//无返回

【文件.类型 文件类型】
用法：
是 a = "%abc"
是 b = 文件.类型(a)

//返回一个整数，1为文件  2为文件夹  -1为不存在


【字符.替换 替换字符】
用法：

是 a = "123456789"
是 b = "2"
是 c = "0"
是 d = 字符.替换(a, b, c)

//返回 替换后的字符
工具.输出(d)

//支持正则表达式
是 d = 字符.替换(a, b, c, true)

【字符.取出 取出字符】
用法：

是 a = "123456789"
是 b = "23"
是 c = "78"
是 d = 字符.取出(a, b, c)

//返回 取出后的字符
工具.输出(d)

是 b = 2
是 c = 6
是 d = 字符.取出(a, b, c)

//返回 取出后的字符
工具.输出(d)


【字符.分割 分割字符】
用法：

是 a = "12,34,56,789"
是 b = ","
是 d = 字符.分割(a, b)

// 循环数组
循环 是 e, d
{
  工具.输出(e)
}

// 支持正则表达式
是 d2 = 字符.分割(a, b, true)

【字符.查询 从头查询字符位置】
用法：

是 a = "123456789"
是 b = "56"
是 d = 字符.查询(a, b)

//返回 查询的字符位置
工具.输出(d)

// 设置查询的起始位置，从位置 2 开始查询
是 c = 2
是 d = 字符.查询(a, b, c)

//返回 查询的字符位置
工具.输出(d)


【字符.倒查 从尾倒查询字符位置】
用法：

是 a = "123456789"
是 b = "56"
是 d = 字符.倒查(a, b)

//返回 查询的字符位置
工具.输出(d)

// 设置查询的起始位置，从位置 2 开始查询
是 c = 2
是 d = 字符.倒查(a, b, c)

//返回 查询的字符位置
工具.输出(d)


【字符.长度 获取字符长度】
用法：

是 a = "123456789"
是 d = 字符.长度(a)

//返回 字符的长度
工具.输出(d)

【字符.去除头尾空格 去除头尾空格】
用法：

是 a = "  123456789 "
是 d = 字符.去除头尾空格(a)

//返回 字符的将去除头尾空格
工具.输出(d)


【字符.转换小写 转换为小写】
用法：

是 a = "aBcDefGh"
是 d = 字符.转换小写(a)

//返回 字符的将转换为小写
工具.输出(d)


【字符.转换大写 转换为大写】
用法：

是 a = "aBcDefGh"
是 d = 字符.转换大写(a)

//返回 字符的将转换为大写
工具.输出(d)


【字符.随机数 生产范围随机数】
用法：

是 a = 1000
是 b = 9999
是 d = 字符.随机数(a, b)

工具.输出(d)


【工具.暂停 暂停代码】
// 创建线程
工具.线程(){

// 工具.暂停(以毫秒为单位，1秒=1000毫秒)
工具.暂停(1000)
工具.输出("1秒后")

工具.暂停(3000)
工具.输出("3秒后")

}

【数组】
用法：
是 sz = { "a", "b", "c", "d" }
是 sz2 = { 1, 2, 3, 4 }
是 sz3 = 创建.string[5]

// 循环数组
循环 是 e, sz
{
  工具.输出(e)
}

// 访问指定维度
是 a = sz[0]
工具.输出(a)

// 获取数据长度
是 d = sz.length
工具.输出(d)


【网络.获取 获取网页源码】
用法：

// 需要注意的是 网络.获取 需要放入线程中执行；

// 创建线程
工具.线程(){

// 网址
是 a = "https://m.baidu.com"

// post提交的数据，对应name1=value1&name2=value2，这个参数可以设置 null 则为 get方式
是 b = { "name1=value1", "name2=value2" }

// 编码
是 c = "utf-8"

// 传递cookie项值，格式为nama=value 下例： uid=112;name=nihao;sb=123456789;
是 d = "uid=112;name=nihao;sb=123456789;"

// 带自动设置cookie方式获取网页，并记录当前网页的Cookie
是 e = true

// 设置Header头:（可设置多条，以“||”隔开）文件头包括了Cookie，User-Agent设备型号
是 f = "User-Agent=Mozilla/5.0 (iPad; U; CPU OS 6_0 like Mac OS X; zh-CN; iPad2)||accept=*/*||accept-language=zh-CN"

// get方式：网址，编码
是 sts = 网络.获取(a, c)

// post方式：网址，数据，编码
是 sts = 网络.获取(a, b, c)

// post方式：网址，数据，编码，传递cookie
是 sts = 网络.获取(a, b, c, d)

// post方式：网址，数据，编码，传递cookie, 是否自动设置cookie，设置Header头，设置连接超时，设置接收超时
是 sts = 网络.获取(a, b, c, d, e, f, 20000, 20000, null)

// post方式：网址，数据，编码，传递cookie, 是否自动设置cookie，设置Header头，设置连接超时，设置接收超时，设置代理IP（若不设置就传入null）
是 sts = 网络.获取(a, b, c, d, e, f, 20000, 20000, "10.0.0.172:80")

//返回 网页源码
工具.输出(st2)

}


【网络.获取json 获取源码并且提交json内容】
用法：

// 需要注意的是 网络.获取json 需要放入线程中执行；

// 创建线程
工具.线程(){

// 网址
是 a = "https://m.baidu.com"

// post提交的数据，对应json内容，这个参数可以设置 null 则为 get方式
是 b = "{\"id\":1, \"name\":\"xiaobai\", \"age\":16}"

// 编码
是 c = "utf-8"

// 传递cookie项值，格式为nama=value 下例： uid=112;name=nihao;sb=123456789;
是 d = "uid=112;name=nihao;sb=123456789;"

// 带自动设置cookie方式获取网页，并记录当前网页的Cookie
是 e = true

// 设置Header头:（可设置多条，以“||”隔开）文件头包括了Cookie，User-Agent设备型号
是 f = "User-Agent=Mozilla/5.0 (iPad; U; CPU OS 6_0 like Mac OS X; zh-CN; iPad2)||accept=*/*||accept-language=zh-CN"

// post方式：网址，数据，编码
是 sts = 网络.获取json(a, b, c)

// post方式：网址，数据，编码，传递cookie
是 sts = 网络.获取json(a, b, c, d)

// post方式：网址，数据，编码，传递cookie, 是否自动设置cookie，设置Header头
是 sts = 网络.获取json(a, b, c, d, e, f)

// post方式：网址，数据，编码，传递cookie, 是否自动设置cookie，设置Header头，设置连接超时，设置接收超时，设置代理IP
是 sts = 网络.获取json(a, b, c, d, e, f, 20000, 20000, "10.0.0.172:80")

//返回 网页源码
工具.输出(st2)

}


【网络.下载 下载文件】
用法：

// 创建线程
工具.线程(){

是 a = "https://m.baidu.com/static/index/plus/plus_logo.png"
是 b = "%plus_logo.png"
是 d = 网络.下载(a, b)

//返回 下载状态码，0为下载成功，1为下载已重复，-1为下载失败
工具.输出(d)

}

【网络.访问 访问网页】
用法：
是 a = "https://m.baidu.com"
网络.访问(a)


【工具.跳转 跳转界面】
用法：
// 跳转 abc.iyu 界面
工具.跳转("abc")

// 或
工具.跳转(abc.lei)


//或 根据包名+类名 跳转 com.iapp.abc 界面，访问 com.iapp 包的 abc.iyu 界面
工具.跳转("com.iapp.abc")


// 跳转 abc 界面，并携带数据，数据为2个数组；要求相互对应 name : value 数据是对应的，包括长度也需要一样（如它们同样都是3个）；
是 name = { "name1", "name2", "name3" }
是 value = { "value1", "value2", "value3" }
工具.跳转("abc", name, value)


Bundle bundle = 自定义一个 Bundle
工具.跳转("abc", bundle)


【数据.获取跳转 获取跳转的数据】
用法：
// 当跳转界面后，可以再跳转后的界面进行获取相关数据

// 根据 name 来获取它的值
是 name1 = 数据.获取跳转("name1")
工具.输出(name1)


// 直接获取 Bundle
是 bundle = 数据.获取跳转()
工具.输出(bundle)


【视图.弹窗 弹窗界面】
用法：
是 tb = 资源.图像.i
是 bt = "标题"
是 nr = "内容"
是 an1 = "按钮1"
是 an2 = "按钮2"
是 an3 = "按钮3"


// 无按钮
是 tc1 = 视图.弹窗(bt, nr)

// 有图标 无按钮
是 tc2 = 视图.弹窗(tb, bt, nr)

// 有图标 1个按钮
是 tc2 = 视图.弹窗(tb, bt, nr, an1){

工具.输出("按钮1")

}


// 有图标 2个按钮
是 tc2 = 视图.弹窗(tb, bt, nr, an1, an2){

工具.输出("按钮1")

}, {

工具.输出("按钮2")

}

// 有图标 3个按钮
是 tc2 = 视图.弹窗(tb, bt, nr, an1, an2, an3){

工具.输出("按钮1")

}, {

工具.输出("按钮2")

}, {

工具.输出("按钮3")

}

// 变量 nr 可输入布局视图
// 弹窗返回对象类型 AlertDialog , 可调用方法关闭弹窗

// 关闭指定的弹窗
tc2.dismiss()


【工具.关闭 关闭界面】
用法：

// 关闭当前界面
工具.关闭()


【工具.显示桌面 显示桌面】
用法：

// 显示桌面
工具.显示桌面()


【工具.媒体播放 媒体播放】
用法：

// 输入媒体数据源
// 本地媒体，支持格式 3gp,mp3,mp4,mkv,wav,ogg,ts,aac
是 mt = 工具.媒体播放("%abc.mp3")

// 网络媒体，支持协议 http / https / rtsp
是 mt2 = 工具.媒体播放("http://www.abc.com/abc.mp3")


// raw资源 输入资源文件的ID
是 mt2 = 工具.媒体播放(zy.raw.mp3)

// 带回调的方法
是 mt = 工具.媒体播放("%abc.mp3"){
// 播放结束后调用

}

// 开始播放
mt.开始()

// 暂停
mt.暂停()

// 停止
mt.停止()

// 释放资源
mt.释放()

// 当前播放状态，返回整数型 1正在播放，0没有播放，-1获取失败
是 bfzt = mt.播放状态()

// 获取媒体的时长（毫秒）
是 mtsc = mt.媒体时长()

// 获取当前播放位置（毫秒）
是 bfwz = mt.播放位置()

// 重播
mt.重播()

// 指定播放的位置（毫秒）
// 1分钟后
是 tz = 60000
mt.指定播放位置(tz)

// 播放器的音量（0-100），左声道与右声道
mt.播放音量(100, 100)

// 设置是否循环播放
mt.循环播放(true)

// 设置播放完毕后自动释放资源
mt.自动释放()

【工具.发通知 发送通知】
用法：
是 tsbt = "提示标题"
是 bt = "标题"
是 test = "内容"
是 icon = 资源.图像.i
// 点击通知后跳转到 abc.iyu 界面
是 iyu = abc.lei

// 无附带参数
工具.发通知(tsbt, bt, test, icon, iyu)

// 布局
是 layout = null

// 附带参数
是 name = { "name1", "name2", "name3" }
是 value = { "value1", "value2", "value3" }
工具.发通知(tsbt, bt, test, icon, layout, iyu, name, value)

// 注意，需要给予应用通知权限，否则无效

【视图.悬浮窗 悬浮窗】
用法：
是 v = 视图控件
是 k = 200
是 g = 200
是 x = 100
是 y = 100

// 创建并显示悬浮窗
是 xfc = 视图.悬浮窗(v, k, g, x, y)

// 设置视图显示位置
xfc.位置(x, y)

// 设置视图大小
xfc.宽高(k, g)

// 设置是否相应事件
xfc.相应事件(true)

// 移除视图，可用于暂时隐藏悬浮视图
xfc.移除()

// 添加视图，隐藏后需要再显示就添加回来
xfc.添加()

// 更新，在对悬浮窗的位置、大小等操作后，需要调用更新。
xfc.更新()

// 注意，需要给予应用权限，否则无法显示


【列表适配器的操作】
用法：

// 获取列表控件
是 lb = 视图.列表(资源.编号.lb1)

// 获取列表适配器
// 输入界面对象（item.iyu），输入布局资源
是 lbspq = lb.列表适配器(item.lei, 资源.布局.item)
// v7 列表的适配器
//是 v7lbspq = lb.v7列表适配器(item.lei, 资源.布局.item)


// 单项目载入布局完成后，调用事件；可用于单项目布局的调整
是 lbspq2 = lb.列表适配器(item.lei, 资源.布局.item)(ua,pn,vw){
// 载入布局完成后调用

}


// 这里是 界面 item.iyu 上面的2个控件的ID
是 ids = { 资源.编号.wb1, 资源.编号.wb2 }
// 对应设置显示的数据值
是 values = { "小明", "18岁" }
// 添加到列表中
lbspq.加(ids, values)

// 如果需要给列表中图像控件设置图像，可设置路径 或远程网络图像，如
// 这里是 界面 item.iyu 上面的2个控件的ID
// 是 ids = { zy.i.wb1, zy.i.wb2, zy.i.tx1, zy.i.tx2 }
// 对应设置显示的数据值
// 是 values = { "小明", "18岁", "%1.png", "http://abc.com/1.png" }
// 添加到列表中
// lbspq.加(ids, values)


// 对列表适配器中数据修改后，记得刷新数据
lbspq.刷新()

// 删除指定位置的数据
是 sc = lbspq.删除(0)

// 删除所有数据
lbspq.删除()

// 获取指定位置的数据
是 hq = lbspq.获取(0)

// 获取指定位置的指定ID的数据
是 hq2 = lbspq.获取(0, 资源.编号.wb2)

// 设置指定位置的数据对象
lbspq.设置(0, hq)

// 设置指定位置的指定ID的数据
lbspq.设置(0, 资源.编号.wb2, "18岁")

// 获取适配器中数据项目的总数
是 cd = lbspq.总数()

// 其中列表的项目所用的布局是界面 item.iyu 上面的布局，并且布局控件可以设置事件。

// 在其事件中获取相关列表适配器数据

// 如 item.iyu界面中 ID 资源.编号.wb1 的控件 的 单击触屏事件 获取 列表适配器数据



// 列表数据操作
是 lb2 = 数据.列表(vw)

// 获取列表适配器
是 lbsqp = lb2.列表适配器()

// 获取触发控件的位置
是 lbcfwz = lb2.列表触发位置()

// 获取触发控件的数据对象
是 lbcfsj = lb2.列表触发数据()

// 获取指定ID的对应数据，获取结果 小明
是 lbcfsj2 = lb2.列表触发数据(资源.编号.wb1)

// 获取指定位置 和 指定ID的对应数据，获取结果 小明
是 lbsj1 = lb2.列表数据(0, 资源.编号.wb1)

// 获取指定位置数据对象
是 lbsj2 = lb2.列表数据(0)

// 获取列表数据对象
是 lbsj3 = lb2.列表数据()

// 获取项目根视图控件
是 lbxmst = lb2.列表项目视图()


【系统.发送短信 发送短信】
用法：
是 a = "10086"
是 b = "0"
系统.发送短信(a, b)

注意:测试时只显示syso日志，不直接 发送短信，打包即可。

【系统.拨打电话 拨打电话】
用法：
是 a = "10086"
系统.拨打电话(a)

注意:测试时只显示syso日志，不直接 拨出号码，打包即可。

【系统.时间 当前时间】
用法：
是 a = 0
是 b = 系统.时间(a)
工具.输出(b)

说明：
第一个参数为时间类型

[数字类型]
0：2014-07-07 09:10:08
1：2014/07/07 09:10:08
2：2014-07-07
3：09:10:08
4：18144133553151
5：07-07 09:10:08
6：2014年07月07日 09:10:08
[字符类型，输入字符形式需引号概括]
%1$tY 年
%1$tm 月
%1$td 日
%1$tH 时
%1$tM 分
%1$tS 秒
%1$tL 毫秒
%1$tA 星期几 或 %1$ta 星期几

【获取屏幕相关分辨率】

用法：

//获取屏幕宽度
是 k = 系统.屏幕().宽
//获取屏幕高度
是 g = 系统.屏幕().高

//获取顶部状态栏高度
是 ztl = 系统.屏幕().状态栏

// 状态栏 false为隐藏 true为显示
系统.屏幕().状态栏(false)

// 设置状态栏颜色
// 输入状态栏颜色（#00000000为透明），状态栏文字颜色（0为白色，1为黑色）
系统.屏幕().状态栏("#ffffff", 1)

//获取底部虚拟按键高度
是 xnaj = 系统.屏幕().虚拟按键

// 底部虚拟按键 false为隐藏 true为显示
系统.屏幕().虚拟按键(false)

// 设置屏幕 false为竖屏 true为横屏
系统.屏幕().横竖屏(true)

// 设置屏幕亮度 1 - 100
系统.屏幕().亮度(50)

【系统.打开应用 打开App应用】
用法：
系统.打开应用("com.iapp")

//或 带有指定类名的启动
系统.打开应用("com.iapp", "com.iapp.MakeiApp")

【系统.应用列表 获取App列表】
用法：
// 输入获取是否包含系统应用
是 sz = 系统.应用列表(false)
循环 是 app, sz
{
// 包名
工具.输出(app.bm)

// 图标
工具.输出(app.tb)

// 标题
工具.输出(app.bt)

// 版本
工具.输出(app.bb)

// 版本号
工具.输出(app.bbh)
}


【系统.卸载应用 卸载应用】
用法：
系统.卸载应用("com.iapp")

说明：
输入应用包名

【网络.上传文件 上传文件】
用法：
是 a = "http://abc.com/upfile.php"
是 b = { "filename=iApp我的应用.apk", "test=非常好的应用哦" }
是 c = { "%abc/iApp.apk", "%abc/iApp2.apk" }
是 d = "utf-8"

// 上传文件
是 e = 网络.上传文件(a, b, c, d)


// 设置 上传文件的name标签（非文件名），这个标签对应后台的设置，设置不当可能后台无法接收到文件
是 a = "http://abc.com/upfile.php"
是 b = { "filename=iApp我的应用.apk", "test=非常好的应用哦" }
// 将这个文件设置为 img name标签，不设置的话默认为 file
是 c = { "img\n%abc/iApp.apk"}
// 支持多文件上传，多文件设置name标签需要在尾部加 []  比如 img[]
是 c = { "img[]\n%abc/iApp.apk", "img[]\n%abc/iApp2.apk" }
是 d = "utf-8"
// 上传文件
是 e = 网络.上传文件(a, b, c, d)



//设置 header文件头，文件头包括了Cookie，User-Agent设备型号。。
是 f = "User-Agent=Mozilla/5.0 (iPad; U; CPU OS 6_0 like Mac OS X; zh-CN; iPad2)||Cookie=aa:123;bb:456;||accept-language=zh-CN"
是 g = 网络.上传文件(a, b, c, d, f)

【动态创建控件】
用法：
// 创建文本控件
文本 wb = 视图.文本()
// 设置ID 也可以不设置ID
wb.id(10087)
// 设置宽高 -1为最大，-2为自适应
wb.宽高(-2, -2)
// 其他的设置
wb.字符("你好")

// 获取一个显示的布局控件作为父控件
线性布局 xxbj = 视图.线性布局(资源.编号.xxbj1)

// 添加控件
xxbj.加(wb)


// 删除子视图
是 a = xxbj.删除(wb)

// 删除全部子视图
是 b = xxbj.删除全部()

// 获取子视图对象列表
是 c = xxbj.子列表()

// 获取从父控件中获取指定视图
是 d = 视图.文本(资源.编号.xxbj1, 10087)

// 获取控件原对象
线性布局 xxbj = 视图.线性布局(资源.编号.xxbj1)
是 e = xxbj.视图

// 获取控件原View对象
是 e2 = 视图.视图(资源.编号.xxbj1)

// 获取控件原View对象，输入父控件ID或对象，输入要获取的控件ID
是 e2 = 视图.视图(资源.编号.xxbj1, 10087)

【工具.图像处理 图像处理】
用法：
是 t = 工具.图像处理("%1.jpg")

// 是否开启编辑图像后更新对象；true时如你对图像进行了裁剪，再次裁剪则以上次裁剪的基础进行继续裁剪。以及裁剪后可直接保存图像；false时图像编辑后，再次编辑还是以原始图像状态进行编辑。
t.更新图像(true)

// 获取图像大小
// 图像的宽
是 k = t.宽
// 图像的高
是 g = t.高

// 裁剪图像区域（像素）：x坐标:80，y坐标:90，裁剪宽度:50，裁剪高度:60
是 a = t.裁剪(80, 90, 50, 60)

// 旋转图像，负值为逆时针旋转，正值为顺时针旋转
是 b = t.旋转(180)

// 缩放图像，值小于1 则为缩小，否则为放大
是 c = t.缩放(0.5)

// 缩放图像，输入指定的宽高进行缩放
是 c2 = t.缩放(100, 200)

// 图像反转，0为水平反转，1为垂直反转
是 d = t.反转(1)

// 保存图像
是 e = t.保存("%1.jpg")

// 保存图像，并指定图像质量(1-100)
是 e2 = t.保存("%1.jpg", 100)


// 输入指定的图像对象进行保存
是 t2 = 工具.图像处理("%1.jpg")
是 a2 = t2.裁剪(80, 90, 50, 60)
// 输入图像对象，保存的路径，指定图像质量(1-100)
是 e3 = t2.保存(a2, "%1.jpg", 100)


【系统.剪切板写入 剪切板写入文本】
用法：
是 a = "nihao"
系统.剪切板写入(a)

说明：
可用于复制到剪切板，其他应用可获取到此数据。

【系统.剪切板获取 剪切板获取文本】
用法：
是 a = 系统.剪切板获取()
工具.输出(a)

说明：
可获取剪切板数据，得到其他地方写入的剪切板数据。

【系统.设备休眠 设备休眠】
用法：

// 设置为不休眠
系统.设备休眠(false)

说明：
设置后手机将不休眠，不锁屏。默认为 true 需要休眠。注意需要权限 android.permission.WAKE_LOCK

【视频播放】
用法：

// 获取视频控件
是 sp1 = 视图.视频(zy.id.sp1)

// 输入媒体数据源 3gp、MP4、avi
是 mt = sp1.载入视频("%abc.mp4")

// 网络媒体，支持协议 http / https / rtsp
是 mt2 = sp1.载入视频("http://www.abc.com/abc.mp4")

// 带回调的方法
是 mt = sp1.载入视频("%abc.mp4"){
// 播放结束后调用

}

// 播放
sp1.播放()

// 暂停
sp1.暂停()

// 恢复
sp1.恢复()

// 停止
sp1.停止()

// 当前播放状态，返回整数型 1正在播放，0没有播放，-1获取失败
是 bfzt = sp1.播放状态()

// 获取媒体的时长（毫秒）
是 mtsc = sp1.媒体时长()

// 获取当前播放位置（毫秒）
是 bfwz = sp1.播放位置()

// 指定播放的位置（毫秒）
// 1分钟后
是 tz = 60000
sp1.指定播放位置(tz)


【加载界面】
用法：

// 获取一个线性布局
是 xxbj = 视图.线性布局(资源.编号.xxbj1)

// 设置要被加载的界面 与 界面的布局资源，值为数组可传入多个
是 iyus = { item.lei }
是 iyuzy = { 资源.布局.csjm }

// 添加
xxbj.界面(iyus, iyuzy)


// 滑动窗体与 侧滑窗体 使用方法是一样的
是 iyus = { item.lei, item2.lei, item3.lei }
是 iyuzy = { 资源.布局.csjm, 资源.布局.csjm2, 资源.布局.csjm3 }

// 添加
xxbj.界面(iyus, iyuzy)


【数据转换】
用法：

是 a = 123
是 b = 123.12
是 c = "abc"

// 转换为字符串
是 zfs = 数据.转换(b).转字符串()

// 转为布尔型
是 brx = 数据.转换(b).转是否()

// 转为布尔型，如果转换失败设置结果为false
是 brx2 = 数据.转换(b).转是否(false)

// 转为整数
是 zsx = 数据.转换(b).转整数()
是 zsx2 = 数据.转换(b).转长整()

// 转为整数，如果转换失败设置结果为0
是 zsx3 = 数据.转换(b).转整数(0)
是 zsx4 = 数据.转换(b).转长整(0)

// 转为浮点型
是 fdx = 数据.转换(b).转小数()
是 fdx2 = 数据.转换(b).转双精小数()

// 转为浮点型，如果转换失败设置结果为0
是 fdx3 = 数据.转换(b).转小数(0)
是 fdx4 = 数据.转换(b).转双精小数(0)

// dip转换px
是 px = 数据.转换(a).dp转px()

// px转换dip
是 px = 数据.转换(a).px转dp()

// px转换sp
是 px = 数据.转换(a).px转sp()

// sp转换px
是 px = 数据.转换(a).sp转px()

// 获取数据类型
是 lx = 数据.转换(c).类()

【设备信息】
用法：

// 设备SDK
是 sdk = 系统.设备信息().sdk

// 设备版本
是 bb = 系统.设备信息().版本

// 设备品牌
是 pp = 系统.设备信息().品牌

// 设备型号
是 xh2 = 系统.设备信息().型号

// 设备cpu型号
是 cpuxh = 系统.设备信息().cpu型号()

// 设备cpu频率
是 cpupl = 系统.设备信息().cpu频率()

// 设备cpu类型
是 cpulx = 系统.设备信息().cpu类型()

// 设备imei，需要权限 android.permission.READ_PHONE_STATE
是 cpulx = 系统.设备信息().imei()

// 设备imsi，需要权限 android.permission.READ_PHONE_STATE
是 cpulx = 系统.设备信息().imsi()

// 获取设备唯一识别码
是 id = 系统.设备信息().id()


【系统.ycxnjp 强制隐藏虚拟键盘】
用法：

// 隐藏虚拟键盘
系统.隐藏虚拟键盘()


【网络.下载管理 下载管理】
用法：
是 a = "%down/temp"
是 b = "%down/save"

//并发线程上限数量（-1为默认，1为单任务，N为多任务）线程数量过多可能造成卡顿
是 c = -1

是 d = 25000
是 e = false

// 输入文件保存路径
是 xzgl = 网络.下载管理(b){

工具.输出("每个项目下载后都会调用")
}

// 输入临时文件路径，文件保存路径
是 xzgl = 网络.下载管理(a, b){

工具.输出("每个项目下载后都会调用")
}

// 输入临时文件路径，文件保存路径，并发线程上限数量，超时，是否覆盖重复
是 xzgl = 网络.下载管理(a, b, c, d, e)(ii, dt, dr){

工具.输出("每个项目下载后都会调用")

// 获取相关数据

// ii 下载项目序号
// dt 下载项目对象
// dr 下载管理器

// 下载文件的字节大小
是 dx = dt.大小

// 已下载字节数
是 yxz = dt.已下载

// 下载项目标题
是 bt = dt.标题

// 网址
是 wz = dt.网址

// 文件路径
是 wjlj = dt.文件路径

// 自定义数据
是 数据. = dt.数据

// 获取状态，0为还未开始，1正在运行，2已完成
是 zt = dt.状态()

}



// 重设置目录
xzgl.目录(a, b)


是 f = "http://abc.com/1.jpg"

// 添加下载项目
// 输入网址
xzgl.加(f)

// 输入网址，自定义数据
xzgl.加(f, "自定义数据")

// 输入网址，保存的路径，自定义数据
xzgl.加(f, "%abc1.jpg", "自定义数据")

// 输入网址，保存的路径，项目标题，自定义数据
xzgl.加(f, "%abc1.jpg", "name", "自定义数据")

// 获取下载列表
是 lb = xzgl.列表


【网络.下载管理器 下载管理器】
用法：
// 临时文件存放路径
是 a = "%down/temp"
// 下载文件存放路径
是 b = "%down/save"

//同时下载任务
是 c = 3

//单任务开启线程的上限；比如你同时下载3个任务，单任务线程上限为3 那么总共就开启了 9个线程进行下载
是 d = 3

//连接失败重试次数
是 e = 3

//连接超时时间，毫秒
是 f = 20000


// 输入临时文件路径，文件保存路径
是 xzglq = 网络.下载管理器(a, b)
(zt, wjlj, data, dt){
// zt 状态  0为等待下载；1为正在下载；2为下载完成；3下载已经暂停或停止；4安装中；-1下载失败
// wjlj 文件路径  data 自定义的数据  dt 下载对象

工具.输出(zt + " 每个项目下载后都会调用 " + wjlj)

}


// 输入临时文件路径，文件保存路径，同时下载任务，单任务开启线程的上限，连接失败重试次数，连接超时时间
是 xzglq = 网络.下载管理器(a, b, c, d, e, f)
(zt, wjlj, data, dt){
// zt 状态  0为等待下载；1为正在下载；2为下载完成；3下载已经暂停或停止；4安装中；-1下载失败
// wjlj 文件路径  data 自定义的数据  dt 下载对象

/*
下载对象的字段与方法
//下载配置
dt.downConfig
//下载ID
dt.编号
//下载URL链接
dt.链接
//指定文件保存位置
dt.文件路径
//当前url的md5
dt.路径md5
//指定文件保存目录
dt.目录
//指定文件保存的文件名
dt.文件名
//文件的大小
dt.文件大小
//已下载
dt.已下载
//下载速度
dt.下载速度
//下载百分比
dt.下载百分比
//下载状态 0为等待下载；1为正在下载；2为下载完成；3下载已经暂停或停止；4安装中；-1下载失败；-2已删除
dt.下载状态
//单任务启动线程上限
dt.线程上限
//单任务已启动线程数量
dt.线程数量
//是否停止当前下载；true为停止
dt.是否停止下载
//标题
dt.标题
//用户自定义数据
dt.数据
//下载管理器对象
dt.下载管理器

//开始下载 注意下载状态为 0 3 -1 时才可调用成功
是 dtks = dt.开始()
//停止下载 注意下载状态为 1 时才可调用成功
是 dttz = dt.停止()

*/

工具.输出(zt + " 每个项目下载后都会调用 " + wjlj)

}


是 wz = "http://abc.com/1.jpg"

// 添加下载项目
// 输入网址，文件名（注意是文件名不是完整路径）
xzglq.加(wz, "abc1.jpg")

// 输入网址，文件名，自定义数据
xzglq.加(wz, "abc1.jpg", "自定义数据")

// 输入网址，文件名，项目标题，自定义数据
xzglq.加(wz, "abc1.jpg", "name", "自定义数据")

// 输入网址，目录路径，文件名，项目标题，自定义数据
xzglq.加(wz, "%down/save2", "abc1.jpg", "name", "自定义数据")

// 开始下载，每次添加下载项目后会自动开始下载
xzglq.开始()

// 获取下载，根据下载连接来获取已存在的下载，返回下载对象
是 dt = xzglq.获取下载(f)


// 获取下载列表
是 lb = xzglq.列表


【网络.web服务器 Web服务器】
用法：

// web服务器开启后，可用浏览器进行访问你的站点

//本机访问地址 http://127.0.0.1:8888/iyu-helpV5.0.txt
//局域网访问地址 http://局域网IP:8888/iyu-helpV5.0.txt
//外网访问地址 http://外网IP:8888/iyu-helpV5.0.txt

//局域网IP 可在手机设置里找，一般在wifi设置 或 系统关于、状态等里面。
//外网，需要有外网IP。并且需要端口映射8888端口。


// 需要启用线程
工具.线程{

// 创建web站点
// 输入端口，站点的文件夹路径
是 web = 网络.web服务器(8888, "%iApp")

// 开始启动web服务器，这里线程会被堵塞
web.开始()

// 下面的代码将在服务器关闭后执行
工具.输出("服务器已关闭")

}


// 使用裕语言V5扩展开发站点
// 例如，做个用户后台。先解析http请求头ct变量，这是字符串类型，你可以先打印数据出来看看字符串格式，再截取需要的
// 可以截取 http请求头 的 post 或 get 数据，这是用户提交的数据。然后使用数据库 数据.sjk 进行保存或 查询，最后输出需要输出的html内容。

工具.线程{

// 创建web站点
// 输入端口，站点的文件夹路径
是 web = 网络.web服务器(8888, "%iApp")(wb,sk,ct){

//wb 是站点对象，就是s web对象
//sk 选择键的对象，用于数据处理
//ct 用户发送连接的http请求头，需要你自行解析该字符串，还包含get/post等数据
工具.输出("http请求头:" + ct)

// 通过解析http请求头，截取需要的字符串
// 然后用裕语言V5代码处理相关数据
// 然后输出你想要的数据

是 html = "这是我需要输出的<b>数据</b>啊"

// 输出
wb.输出(sk, html)

}

// 开始启动web服务器，这里线程会被堵塞
web.开始()

// 下面的代码将在服务器关闭后执行
工具.输出("服务器已关闭")

}


//子方法

// 开始启动web服务器
web.开始()

// 关闭web服务器
web.关闭()

//404错误的自定义显示内容
web.错误404("找不到文件")

//500错误的自定义显示内容
web.错误500("文件内部错误")

//默认页面文件名
web.默认页面("index.htm")

//访问的文件未添加MIME时，会无法显示，如果给它设置个默认的MIME，就可以显示了
web.mime("text/html;charset=UTF-8")
//web.mime("*/*")

//添加文件的MIME
是 b1 = web.mime(".jar", "application/x-zip-compressed")

//输出自定义数据
wb.输出(sk, "需要输出的数据内容")

//输入选择键的对象，返回状态，输出的内容，输出内容类型，自定义输出的http头信息
是 headers = { "Server: iAppServer" }
wb.输出(sk, 200, "需要输出的数据内容", "text/html;charset=UTF-8", headers)


说明：
可用于web服务器架设，切换后台时需注意：系统可能的进行内存回收，导致服务器被销毁了。

【网络.套接字 套接字 Socket】
用法：

// 需要启用线程
工具.线程(){
// 创建服务端
// 输入服务端口，服务端超时限制(指定时间内无新连接则关闭服务器,0为无限制)，客户端超时限制(已连接的客户端指定时间内未通信则关闭,0为无限制)，是否接收新连接请求
是 tjz = 网络.套接字(6666, 0, 0, true)(so,sr){
// so 服务端对象
// sr 新连接对象

工具.输出(sr.ip() + ":" + sr.dk() + ":" + sr.bjip() + ":" + sr.bjdk())

},(sr,te,mg,bs){
// sr 连接对象
// te 数据类型，0为无数据头字节数组，1为带数据头字符串，2为带数据头文件，3为带数据头字节数组
// mg 数据信息，数据类型为1时值为对应的字符串，数据类型为2时值为文件的后缀
// bs 数据的字节数组

工具.输出(sr + ":" + te + ":" + mg + ":" + bs.length)

}

// 开始，这里线程会被堵塞
tjz.开始()

// 下面的代码将在服务端关闭后执行
工具.输出("服务端已关闭")

}


// 需要启用线程
工具.线程(){
// 创建客户端
// 输入服务器IP，服务端口，超时限制(指定时间内未通信则关闭,0为无限制)
是 tjz = 网络.套接字("192.168.1.100", 6666, 0)(so,sr){
},(sr,te,mg,bs){
// sr 连接对象
// te 数据类型，0为无数据头字节数组，1为带数据头字符串，2为带数据头文件，3为带数据头字节数组
// mg 数据信息，数据类型为1时值为对应的字符串，数据类型为2时值为文件的后缀
// bs 数据的字节数组

工具.输出(sr + ":" + te + ":" + mg + ":" + bs.length)
}

// 开始
tjz.开始()

}


// 更多方法

// 重启
tjz.重启()

// 开始启动或连接
tjz.开始()

// 连接总数
是 ljzs = tjz.连接总数()

// 获取连接列表
是 ljlb = tjz.连接()

// 获取指定序号的连接
是 lj = tjz.连接(0)

// 连接清空
tjz.连接清空()

// 获取当前是否已关闭
是 sfgb = tjz.是否关闭()

// 关闭释放
tjz.关闭()

// 获取服务器对象
是 fwd = tjz.服务器()

// 获取本机的IP
是 bjip = tjz.本机ip()

// 获取本机的端口
是 bjdk = tjz.本机端口()

// 输出数据，返回发送成功数量，如果是服务端则为群发
// 可输出多种类型数据，字符串，字节数组，文件等
工具.线程(){
是 sc1 = tjz.输出("nihao")
}

// 输出数据，需要开线程
工具.线程(){
// 输入数据类型，输入数据内容
是 sc2 = tjz.输出(1, "nihao")
// 输出文件
//s sc2 = tjz.输出(2, "%a.png")
}


// sr 连接对象的方法

// 获取远程连接的IP
是 ip = sr.ip()

// 获取远程连接的端口
是 dk = sr.端口()

// 获取本机的IP
是 bjip = sr.本机ip()

// 获取本机的端口
是 bjdk = sr.本机端口()

// 获取当前是否已关闭
是 sfgb = sr.是否关闭()

// 重启连接
sr.重启()

// 关闭释放
sr.关闭()

// 获取连接socket对象
是 ljdx = sr.连接对象()

// 设置自定义数据
sr.数据("abcd")

// 获取自定义数据
是 数据. = sr.数据()

// 设置自定义数组数据
是 sz = { "abcd", "efg" }
sr.数组数据(sz)

// 获取自定义数组数据
是 szsj = sr.数组数据()

// 输出数据，返回发送成功数量，如果是服务端则为群发
// 可输出多种类型数据，字符串，字节数组，文件等
工具.线程(){
是 sc1 = sr.输出("nihao")
}

// 输出数据
// 输入数据类型，输入数据内容
工具.线程(){
是 sc2 = sr.输出(1, "nihao")
// 输出文件
//s sc2 = sr.输出(2, "%a.png")
}


关于数据头：
数据头是为了更佳简便的使用套接字，为固定模式和长度；
数据头固定为32位；6位固定标识0-5，1位数据类型6-6，10位数据长度7-16，15位文件后缀17-31

// 数据类型: 1为字符串，2为文件，3为字节数组

// java开头固定字节标识 32, -93, 93, 0, 63, -63
// c#开头固定字节标识 32, 163, 93, 0, 63, 193


【网络.数据报 用户数据报协议 UDP】
用法：

// 需要启用线程
工具.线程(){

// 输入本地服务端的端口
是 数据. = 网络.数据报(6666)(cp,dp,bs,ip,dk){
// cp 数据报协议对象
// dp 接收数据对象
// bs 接收的字节数组
// ip 发送者IP
// dk 发送者端口

工具.输出(cp + ":" + dp + ":" + bs + "+" + bs.length + ":" + ip + ":" + dk)
}

// 开始，这里线程会被堵塞
sjb.开始()

// 下面的代码将在服务端关闭后执行
工具.输出("服务端已关闭")

}


// 需要启用线程
工具.线程(){

// 输入远程连接IP，远程连接的端口，输入本地服务端的端口
是 sjb = 网络.数据报("192.168.1.101", 6666, 7777)(cp,dp,bs,ip,dk){
// cp 数据报协议对象
// dp 接收数据对象
// bs 接收的字节数组
// ip 发送者IP
// dk 发送者端口

工具.输出(cp + ":" + dp + ":" + bs + "+" + bs.length + ":" + ip + ":" + dk)
}

// 开始，这里线程会被堵塞
sjb.开始()

// 下面的代码将在服务端关闭后执行
工具.输出("服务端已关闭")

}

// 更多方法

// 开始
sjb.开始()

// 关闭
sjb.关闭()

// 设置最大接收数据长度，需在开始前调用；默认5KB，值越大越可能丢包发送失败。建议10KB内
sjb.数据长度(1024*5)

// 获取连接对象
是 lj = sjb.连接()

// 获取连接的IP
是 ip = sjb.ip()

// 获取连接的端口
是 dk = sjb.端口()

// 获取本机的IP
是 ip = sjb.本机ip()

// 获取本机的端口
是 dk = sjb.本机端口()

// 获取连接是否已释放
是 sfgb = sjb.是否关闭()

// 输出数据
工具.线程(){
是 sc1 = sjb.输出("nihao")
}

// 输出数据
// 输入发送的IP，发送的端口，发送的数据
工具.线程(){
是 sc2 = sjb.输出("192.168.1.102", 7777, "nihao")
}


【字符.正则表达式 正则表达式】
用法：

//字符串
是 a = "qqqq123456eee"
//正则表达式
是 b = "([a-z]+)(\\d+)"
//更多参数
是 c = 0

// 获取正则表达式对象
是 zz = 字符.正则表达式(a, b, c)

//替换成，将替换全部
是 e = zz.替换全部("1:$1, 2:$2")

//替换成，只替换第一个
是 e2 = zz.替换一个("1:$1, 2:$2")

//返回是否匹配成功，需字符串被完全匹配，赋值返回true或 false
是 e3 = zz.是否匹配成功()

//开始匹配 或 匹配下一个，赋值返回true或 false
是 e4 = zz.匹配()

//给定位置序号进行匹配，赋值返回true或 false
是 e5 = zz.匹配(1)

//获取匹配组的数量，当前为2组：([a-z]+)、(\d+)
是 e6 = zz.匹配组数量()

//获取第1组匹配到的子字符串在字符串中的开头位置 
是 e7 = zz.开始位置(1)

//获取第1组匹配到的子字符串在字符串中的结尾位置 
是 e8 = zz.结束位置(1)

//获取第1组匹配到的子字符串
是 e9 = zz.字符(1)
//获取第2组匹配到的子字符串
是 e10 = zz.字符(2)

【系统.功能 设备功能操作】
用法：

是 功能 = 系统.功能()

// 闪光灯 需要权限 android.permission.CAMERA

// 闪光灯开启
功能.闪光灯()

// 闪光灯停止
功能.闪光灯停止()


// 振动 需要权限 android.permission.VIBRATE

// 振动 1秒钟
是 zd1 = 功能.振动(1000)

//静止1秒，振动1秒，静止1秒，振动1秒，静止1秒，振动1秒，静止1秒，..， 并且不重复
//输入振动规则，输入是否重复循环执行
是 gz = { 1000, 2000, 3000, 4000 }
是 zd2 = 功能.振动(gz, false)

//强制停止振动器
功能.振动停止()

// 获取振动状态
是 zd3 = 功能.振动()


// 录音 需要权限 android.permission.RECORD_AUDIO
是 ly1 = 功能.录音("%1.amr")

// 录音停止
是 ly2 = 功能.录音停止()



// 录制屏幕
//输入储存录制文件路径，输入视频宽度，输入视频高度，输入视频码率（码率可以设置大些视频会清晰些），输入视频帧率
功能.录屏幕("%123.mp4", 1280, 720, 1024000, 30)

//开始录制
功能.录屏幕开始()

//停止录制
功能.录屏幕停止()

//释放资源
功能.录屏幕释放()

//判断是否正在录制
功能.正在录屏幕()

//录屏幕回调；注意：需要此代码放入 回调结果 界面事件，否则将无法录制
功能.录屏幕回调(re, rc, it)


说明：
用于手机屏幕录制。

注意：
录屏幕仅支持系统Android 5.0以及以上才有效果！
Android 5.0以下的系统，无效果！



// 截屏
是 jp1 = 功能.截屏("%123.jpg", 70)


// 调用拍摄相片，拍摄后会调用 界面事件》回调结果  方法第一个参数结果为 63930
// 输入拍摄的相片保存位置
功能.拍摄相片("%1.jpg")


// 相册选择，选择后会调用 界面事件》回调结果  方法第一个参数结果为 63931
// 需要通过 数据.hquri(it) 来获取结果
功能.相册选择()

// 相册选择获取结果
// 输入 界面事件》回调结果 方法的第三个参数
是 xcxz1 = 数据.获取uri(it)


// 视频拍摄，拍摄后会调用 界面事件》回调结果  方法第一个参数结果为 63932
// 需要通过 数据.获取uri(it) 来获取结果
功能.视频拍摄()

// 相册视频拍摄结果
// 输入 界面事件》回调结果 方法的第三个参数
是 xcxz2 = 数据.获取uri(it)



// 系统截屏，可全系统截屏 需5.0以及以上设备

// 1. 首先需系统截屏初始化，初始化后会异步调用 回调结果 界面事件
功能.系统截屏初始化();

//2. 系统截屏回调 返回null 则失败；注意：需要此代码放入 回调结果 界面事件，否则将无法截屏
功能.系统截屏回调(re, rc, it)

//3. 然后在其他事件里就可以截屏了，你也可以弄个悬浮按钮的事件来执行截屏代码

//开始系统截屏返回 图像对象
是 b = 功能.系统截屏()

//开始系统截屏，输入延迟毫秒（3秒）
是 b2 = 功能.系统截屏(3000)

//开始系统截屏，输入延迟毫秒（3秒），保存图像路径
是 b2 = 功能.系统截屏(3000, "%1.png")

//开始系统截屏，输入延迟毫秒（3秒），保存图像路径，图像的质量（1-100）
是 b2 = 功能.系统截屏(3000, "%1.png", 90)


// 传感器，如果设备不支持该传感器将返回 变量c 为 false
输入传感器类型值，输入传感器延迟类型
是 c = 功能.传感器(1, 2)(参数对象){
//传感器已更新
// 参数对象 参数对象，用于传感器参数的传递

// 获取传感器更新的数值数组，这个数值数组是float[]类型，里面是传感器的实时反馈数据。
是 数组 = 参数对象.values

// 可以根据这数值数组的数据，来进行对应的应用操作等等~ 这里就不演示，这里将数值数组打印出来
循环 是 数, 数组
{
工具.输出("数值:" + 数)
}

}, (传感器类型, 新精度){
//精度变化
// 传感器类型 传感器类型对象，注意这是对象。如果要获取对应的 传感器类型值可用 sr.getType()
// 新精度 新精度值

// 这里根据项目需求来操作
工具.输出("传感器类型值:" + 传感器类型.getType())
工具.输出("新精度值:" + 新精度)

}

//传感器释放，如果你不使用传感器功能了，调用他可以释放掉其占用的内存和监听事件
//功能.传感器释放()

// 传感器延迟类型
  类型值完整类：android.hardware.SensorManager.SENSOR_DELAY_FASTEST
    尽快获取传感器数据
    延迟类型值：0

  类型值完整类：android.hardware.SensorManager.SENSOR_DELAY_GAME
    适用于游戏
    延迟类型值：1

  类型值完整类：android.hardware.SensorManager.SENSOR_DELAY_UI
    适用于用户界面
    延迟类型值：2

  类型值完整类：android.hardware.SensorManager.SENSOR_DELAY_NORMAL
    适用于屏幕方向更改（默认）
    延迟类型值：3


// 传感器类型值与类型说明
  类型值完整类：android.hardware.Sensor.TYPE_ACCELEROMETER
    加速度传感器（重力感应），单位是m/s2，测量应用于设备X、Y、Z轴上的加速度
    传感器类型值：1

  类型值完整类：android.hardware.Sensor.TYPE_MAGNETIC_FIELD
    磁力传感器，单位是uT(微特斯拉)，测量设备周围三个物理轴（x，y，z）的磁场
    传感器类型值：2

  类型值完整类：android.hardware.Sensor.TYPE_ORIENTATION
    方向传感器,测量设备围绕三个物理轴（x，y，z）的旋转角度
    传感器类型值：3

  类型值完整类：android.hardware.Sensor.TYPE_GYROSCOPE
    陀螺仪传感器，单位是rad/s，测量设备x、y、z三轴的角加速度
    传感器类型值：4

  类型值完整类：android.hardware.Sensor.TYPE_LIGHT
    光线感应传感器，单位lx，检测周围的光线强度
    传感器类型值：5

  类型值完整类：android.hardware.Sensor.TYPE_PRESSURE
    压力传感器，单位是hPa(百帕斯卡)，返回当前环境下的压强
    传感器类型值：6

  类型值完整类：android.hardware.Sensor.TYPE_TEMPERATURE
    温度传感器，目前已被TYPE_AMBIENT_TEMPERATURE（传感器类型值： 13）替代
    传感器类型值：7

  类型值完整类：android.hardware.Sensor.TYPE_PROXIMITY
    距离传感器，单位是cm，用来测量某个对象到屏幕的距离
    传感器类型值：8

  类型值完整类：android.hardware.Sensor.TYPE_GRAVITY
    重力传感器，单位是m/s2，测量应用于设备X、Y、Z轴上的重力
    传感器类型值：9

  类型值完整类：android.hardware.Sensor.TYPE_LINEAR_ACCELERATION
    线性加速度传感器，单位是m/s2，该传感器是获取加速度传感器去除重力的影响得到的数据
    传感器类型值：10

  类型值完整类：android.hardware.Sensor.TYPE_ROTATION_VECTOR
    旋转矢量传感器，旋转矢量代表设备的方向
    传感器类型值：11

  类型值完整类：android.hardware.Sensor.TYPE_RELATIVE_HUMIDITY
    湿度传感器，单位是%，来测量周围环境的相对湿度
    传感器类型值：12

  类型值完整类：android.hardware.Sensor.TYPE_AMBIENT_TEMPERATURE
    温度传感器，单位是℃
    传感器类型值： 13

  类型值完整类：android.hardware.Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED
    未校准磁力传感器，提供原始的，未校准的磁场数据
    传感器类型值：14

  类型值完整类：android.hardware.Sensor.TYPE_GAME_ROTATION_VECTOR
    游戏动作传感器，不收电磁干扰影响
    传感器类型值：15

  类型值完整类：android.hardware.Sensor.TYPE_GYROSCOPE_UNCALIBRATED
    未校准陀螺仪传感器，提供原始的，未校准、补偿的陀螺仪数据，用于后期处理和融合定位数据
    传感器类型值：16

  类型值完整类：android.hardware.Sensor.TYPE_SIGNIFICANT_MOTION
    特殊动作触发传感器
    传感器类型值：17

  类型值完整类：android.hardware.Sensor.TYPE_STEP_DETECTOR
    步行检测传感器，用户每走一步就触发一次事件
    传感器类型值：18

  类型值完整类：android.hardware.Sensor.TYPE_STEP_COUNTER
    计步传感器
    传感器类型值：19

  类型值完整类：android.hardware.Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR
    地磁旋转矢量传感器，提供手机的旋转矢量，当手机处于休眠状态时，仍可以记录设备的方位
    传感器类型值：20

  类型值完整类：android.hardware.Sensor.TYPE_HEART_RATE
    心率监测传感器，报告的值是每分钟心跳的心率。
    传感器类型值：21

  类型值完整类：android.hardware.Sensor.TYPE_TILT_DETECTOR
    倾斜传感器，每次检测到倾斜事件时，如果2秒窗口平均重力的方向在自激活传感器以来至少35度。这是一个唤醒传感器。
    传感器类型值：22

  类型值完整类：android.hardware.Sensor.TYPE_WAKE_GESTURE
    手势唤醒传感器，唤醒手势传感器可根据设备特定的运动唤醒设备。
    传感器类型值：23

  类型值完整类：android.hardware.Sensor.TYPE_GLANCE_GESTURE
    手势唤醒传感器，传感器可短暂打开屏幕，使用户能够根据特定动作浏览屏幕上的内容。设备应稍后关闭屏幕。
    传感器类型值：24

  类型值完整类：android.hardware.Sensor.TYPE_PICK_UP_GESTURE
    拾取传感器，无论在何处捡起设备，此类传感器都会触发。
    传感器类型值：25

  类型值完整类：android.hardware.Sensor.TYPE_WRIST_TILT_GESTURE
    腕倾斜手势传感器，当设备表面朝向用户倾斜时，会触发此类传感器。
    传感器类型值：26

  类型值完整类：android.hardware.Sensor.TYPE_DEVICE_ORIENTATION
    设备的当前方向传感器，在内部用于自动旋转和扬声器旋转。
    传感器类型值：27

  类型值完整类：android.hardware.Sensor.TYPE_POSE_6DOF
    6个自由度的姿势传感器，与android.hardware.Sensor.TYPE_ROTATION_VECTOR（传感器类型值：11）相似，但有额外的增量从任意参考点转换。
    传感器类型值：28

  类型值完整类：android.hardware.Sensor.TYPE_STATIONARY_DETECT
    固定检测传感器。
    传感器类型值：29

  类型值完整类：android.hardware.Sensor.TYPE_MOTION_DETECT
    运动检测传感器。
    传感器类型值：30

  类型值完整类：android.hardware.Sensor.TYPE_HEART_BEAT
    运动检测传感器。
    传感器类型值：31

  类型值完整类：android.hardware.Sensor.TYPE_DYNAMIC_SENSOR_META
    动态传感器元事件传感器，动态传感器添加到其中或从中删除动态传感器时，会收到此类型的传感器事件。
    传感器类型值：32

  类型值完整类：android.hardware.Sensor.TYPE_LOW_LATENCY_OFFBODY_DETECT
    低延迟体外检测传感器。
    传感器类型值：34

  类型值完整类：android.hardware.Sensor.TYPE_ACCELEROMETER_UNCALIBRATED
    未校准加速度传感器。
    传感器类型值：35

// 传感器相关权限 android.permission.BODY_SENSORS


【系统.权限管理 权限管理】
用法：
//判断写入权限是否已授权
是 qxgl = 系统.权限管理()
是 xr = qxgl.权限("android.permission.WRITE_EXTERNAL_STORAGE")
工具.输出("写入权限是否已授权:" + xr)


//注意：请求应用权限。请求后结果将在  界面事件》请求权限结果  且参数变量 rc 固定值赋为 60542

//请求当前应用所需的权限
是 qxgl = 系统.权限管理()
// 将请求当前应用 AndroidManifest 中已配置的权限
qxgl.请求权限()

// 请求单个权限
是 qxgl = 系统.权限管理()
// 请求写入权限
qxgl.请求权限("android.permission.WRITE_EXTERNAL_STORAGE")

// 请求多个权限
是 qxgl = 系统.权限管理()
// 同时请求2个及以上的权限，这里用一个数组
是 sz = { "android.permission.WRITE_EXTERNAL_STORAGE", "android.permission.READ_PHONE_STATE" }
// 请求写入权限 和 读取电话状态
qxgl.请求权限(sz)


请求权限结果中的例子：
// 该事件的参数介绍 int rc, String[] ps, int[] gr
// int rc 请求代码请求权限时传入的固定代码
// String[] ps 请求的权限列表
// int[] gr 请求的权限列表的状态结果，该数组的长度与请求的权限列表一致
如果 rc == 60542
{
  如果 ps != null
  {
    是 j = ps.length
    循环 是 i=0, i<j, i++
    {
      如果 gr[i] == -1
      {
        工具.输出("请求失败:" + ps[i])
      }
    }
  }
}


【数据.数据库 数据库操作】
用法：
//连接一个私有数据库，如果不存在将自动新建
//输入数据库文件名
是 sjk = 数据.数据库("iapp.db")


//连接一个公共数据库，如果不存在将自动新建
//输入数据库文件名
是 sjk2 = 数据.数据库("%iapp.db")

// 获取数据库对象
是 sjk3 = sjk.数据库

// 获取数据库是否为新建的
是 sjk5 = sjk.新建

// 删除数据库
是 sjk6 = sjk.删除数据库()

// 释放数据库
是 sjk7 = sjk.释放数据库()

// 创建 info 数据表
是 table = "_id integer primary key,url text, filename text,status interger"
是 sjk8 = sjk.创建数据表("info", table)

// 判断 info 数据表 是否存在
是 sjk9 = sjk.存在数据表("info")

// 删除 info 数据表
是 sjk10 = sjk.删除数据表("info")


//在 info 数据表 添加一条数据
// 数据列名
是 table = "url,filename,status"
// 对应数据
是 data = "'http://abc.com/abc.apk', 'abc.apk', 1"
是 sjk11 = sjk.创建数据("info", table, data)


//在 info 数据表 更新数据，若不需要设置条件(_id=1)可设为 null 视为适用于执行所以数据
是 sjk12 = sjk.更新数据("info", "status=2", "_id=1")


//在 info 数据表 删除数据，若不需要设置条件(_id=1)可设为 null 视为适用于执行所以数据
是 sjk13 = sjk.删除数据("info", "_id=1")


//在 info 数据表 查询数据
//查询，若不需要设置条件(status=1 order by _id desc LIMIT 0,1)可设为 null 视为适用于执行所以数据
// LIMIT <跳过的数据数目>, <取数据数目>
是 table = "_id,url,filename,status"
是 sqlx = "status=1 order by _id desc LIMIT 0,1"
是 sjk15 = sjk.查询数据("info", table, sqlx)

//自定义sql查询
是 sqlx = "select _id,url,filename,status from info where status=1 order by _id desc"
是 sjk16 = sjk.查询数据(sqlx)

// 循环打印数据
循环 sjk15.下一行()
{
// 输出 第一列数据， 第二列数据
工具.输出(":" + sjk15.数据(0)+ ", " + sjk15.数据(1));
}

// 更多操作

//获取光标对象的第一列数据
是 sjk = sjk15.数据(0)

//获取光标对象有多少列
是 sjk = sjk15.查询列数()

//获取总共查询到多少行数据
是 sjk = sjk15.查询行数()

//光标对象移到下一行数据
是 sjk = sjk15.下一行()

//光标对象移到上一行数据
是 sjk = sjk15.上一行()

//光标对象移到第一行数据
是 sjk = sjk15.第一行()

//光标对象移到最后第一行数据
是 sjk = sjk15.最后一行()

//光标对象移到指定第3条数据
是 sjk = sjk15.指定位置(2)

//获取光标对象当前位置
是 sjk0 = sjk15.获取位置()

//释放数据查询
是 sjk1 = sjk15.释放()



//自定义的sql执行，需要对sql语法了解才能灵活运用
是 sqlx = "insert into info (url,filename,status) values ('http://abc.com/abc.apk', 'abc.apk', 1)"
是 sjk17 = sjk.查询数据(sqlx)


注意：
在执行sql语句的时候，需要注意你的字符串的特殊字符的转义。
     /   ->    //
     '   ->    ''
     [   ->    /[
     ]   ->    /]
     %   ->    /%
     &   ->    /&
     _   ->    /_
     (   ->    /(
     )   ->    /)

【数据.md5 获取MD5吗】
用法：

// 输入 File对象，获取文件的md5
// 获取文件对象
是 f1 = 文件.文件("%a.txt")
// 根据文件对象获取md5
是 b1 = 数据.md5(f1)
工具.输出(b1)

// 输入byte[] 获取字节数组的md5
// 获取文件的byte[]字节数组
是 f2 = 文件.zjsz("%a.txt")
// 根据字节数组来获取md5
是 b2 = 数据.md5(f2)
工具.输出(b2)

// 输入字符串 获取字节数组的md5
// 根据字节数组来获取md5
是 b3 = 数据.md5("abcdef")
工具.输出(b3)


【动画操作】
用法：

// 创建动画对象
是 dh = 工具.动画()

// 渐变透明度动画，1 代表不透明，0代表透明；还可以设置0.5等半透明
是 jbtm = dh.渐变透明(1, 0)
// 持续时长
jbtm.持续时长(2000)
// 设置控件执行动画
视图.图像(资源.编号.tx1).动画(jbtm)



//创建一个渐变尺寸伸缩动画
//0为没有，2.5为原始2.5倍
是 jbss = dh.渐变伸缩(0.5, 2.5, 0.5, 2.5)
// 持续时长
jbss.持续时长(2000)
// 设置控件执行动画
视图.图像(资源.编号.tx1).动画(jbss)

位置类型：
0 默认
1 以对象本身为基准位置类型
2 以父控件为基准位置类型

//输入X开始尺寸比例，输入X结束尺寸比例，输入Y开始尺寸比例，输入Y结束尺寸比例，输入X位置类型，输入X坐标的开始位置，输入Y位置类型，输入Y坐标的开始位置
是 jbss2 = dh.渐变伸缩(0.5, 2.5, 0.5, 2.5, 1, 0.5, 1, 0.5)
// 持续时长
jbss2.持续时长(2000)
// 设置控件执行动画
视图.图像(资源.编号.tx1).动画(jbss2)



//创建一个画面位置移动动画
//输入开始X坐标上的移动位置，结束X坐标上的移动位置，开始Y坐标上的移动位置，结束Y坐标上的移动位置
是 wzyd = dh.位置移动(30, 80, 30, 80)
// 持续时长
wzyd.持续时长(2000)
// 设置控件执行动画
视图.图像(资源.编号.tx1).动画(wzyd)



//创建一个画面旋转动画
//输入动画开始的旋转角度，输入动画旋转到的角度
是 xz = dh.旋转(0, 180)
// 持续时长
xz.持续时长(2000)
// 设置控件执行动画
视图.图像(资源.编号.tx1).动画(xz)

位置类型：
0 默认
1 以对象本身为基准位置类型
2 以父控件为基准位置类型

//输入动画开始的旋转角度，输入动画旋转到的角度，输入X位置类型，输入X坐标的开始位置，输入Y位置类型，输入Y坐标的开始位置
是 xz = dh.旋转(0, 180, 1, 0.5, 1, 0.5)
// 持续时长
xz.持续时长(2000)
// 设置控件执行动画
视图.图像(资源.编号.tx1).动画(xz)




// 开始使用 动画集合
是 jh = dh.集合(false)

// 渐变透明度动画
是 jbtm = dh.渐变透明(1, 0)
// 持续时长
jbtm.持续时长(2000)
jh.添加(jbtm)

//渐变尺寸伸缩动画
是 jbss = dh.渐变伸缩(0.5, 2.5, 0.5, 2.5)
// 持续时长
jbss.持续时长(2000)
jh.添加(jbss)

//画面位置移动动画
是 wzyd = dh.位置移动(30, 80, 30, 80)
// 持续时长
wzyd.持续时长(2000)
jh.添加(wzyd)

//画面旋转动画
是 xz = dh.旋转(0, 180)
// 持续时长
xz.持续时长(2000)
jh.添加(xz)

// 添加动画集合完毕后执行这个动画集合
// 设置控件执行动画
视图.图像(资源.编号.tx1).动画(jh)

说明：
常用于动画集合执行。

提示：
动画集合允许被其他动画集合添加成为子动画。

提示：
动画集合如果设置了动画控制属性，同时也会重置所有子控件的属性。





// 开始使用 动画队列执行

//旋转动画
//输入控件ID或控件对象，输入动画类型，输入旋转角度数组...（可输入N个参数）
是 sz = { 60, 180 }
是 xz = dh.队列(资源.编号.tx1, "rotation", sz)
//s sz2 = { 30, 80, 60, 20, 60 }
//dh.队列(资源.编号.tx1, "rotationX", sz2)
//s sz3 = { 30, 80 }
//dh.队列(资源.编号.tx1, "rotationY", sz3)
// 持续时长
xz.持续时长(2000)
// 开始
xz.开始()


//伸缩动画
//输入控件ID或控件对象，输入动画类型，输入伸缩尺寸比例数组...（可输入N个参数）
是 sz4 = { 1.5, 2.5 }
是 ssdh = dh.队列(资源.编号.tx1, "scaleX", sz4)
//s sz5 = { 1.5, 2.5, 1.2, 2.6, 1.3 }
//dh.队列(资源.编号.tx1, "scaleY", sz5)
// 持续时长
ssdh.持续时长(2000)
// 开始
ssdh.开始()


//移动动画
//输入控件ID或控件对象，输入动画类型，输入移动到位置数组...（可输入N个参数）
是 sz6 = { 0, 60 }
是 yddh = dh.队列(资源.编号.tx1, "translationX", sz6)
//s sz7 = { 0, 60, 30, 10, 60 }
//dh.队列(资源.编号.tx1, "translationY", sz7)
// 持续时长
yddh.持续时长(2000)
// 开始
yddh.开始()



//透明度
//输入控件ID或控件对象，输入动画类型，可见度比例数组(0.0至1.0)...（可输入N个参数）
是 sz8 = { 1, 0.3, 1, 0.2, 1 }
是 tm = dh.队列(资源.编号.tx1, "alpha", sz8)
// 持续时长
tm.持续时长(2000)
// 开始
tm.开始()



// 开始使用 队列动画集合

//旋转动画
是 sz9 = { 60, 180 }
是 xz = dh.队列(资源.编号.tx1, "rotation", sz9)
// 持续时长
xz.持续时长(2000)

//伸缩动画
是 sz10 = { 1.5, 2.5 }
是 ssdh = dh.队列(资源.编号.tx1, "scaleX", sz10)
// 持续时长
ssdh.持续时长(2000)

//移动动画
是 sz11 = { 0, 60 }
是 yddh = dh.队列(资源.编号.tx1, "translationX", sz11)
// 持续时长
yddh.持续时长(2000)

//透明度
是 sz12 = { 1, 0.3, 1, 0.2, 1 }
是 tm = dh.队列(资源.编号.tx1, "alpha", sz12)
// 持续时长
tm.持续时长(2000)

// 设置数组
是 sz = { xz, ssdh, yddh, tm }


//队列顺序执行
是 dlsx = dh.队列顺序(sz)

//队列同时执行
是 dlts = dh.队列同时(sz)
//dlts.开始()

// 开始执行动画
dlsx.开始()

说明：
常用于动画集合执行。

提示：
队列动画集合允许被其他队列动画集合添加成为子动画。

提示：
动画集合如果设置了动画控制属性，同时也会重置所有子控件的属性。


// 开始使用 动画控制

// 位置移动动画
是 wzyd = dh.位置移动(30, 80, 30, 80)

// 取消
wzyd.取消()

// 重置属性
wzyd.重置()

// 开始
wzyd.开始()

// 持续时长
wzyd.持续时长(2000)

// 延迟执行
wzyd.延迟执行(1000)

// 启用动画结束填充效果
wzyd.启用填充(true)

// 动画执行后，控件停留执行结束状态
wzyd.停留结束状态(true)

// 动画执行后，控件停留执行开始状态
wzyd.停留开始状态(true)

// 动画重复执行的次数
wzyd.重复执行(6)

// 动画集合添加动画，仅用于动画集合
是 jh = dh.集合(false)
jh.添加(wzyd)

// 动画监听事件
jh.动画事件
{
//当结束动画时
工具.输出("End")
},
{
//当重复动画时
工具.输出("Repeat")
},
{
//当启动动画时
工具.输出("Start")
}


是 sz9 = { 60, 180 }
// 旋转动画
是 xz = dh.队列(资源.编号.tx1, "rotation", sz9)

// 取消
xz.取消()

// 开始
xz.开始()

// 持续时长
xz.持续时长(2000)

// 延迟执行
xz.延迟执行(1000)

// 是否正在运行
是 zzyx = xz.正在运行()

// 设置动画执行的控件
xz.kj(资源.编号.tx1)

// 克隆动画
是 kl = xz.克隆()


// 动画监听事件
xz.动画监听事件{
//当结束动画时
工具.输出("End")
},
{
//当重复动画时
工具.输出("Repeat")
},
{
//当启动动画时
工具.输出("Start")
},
{
//当取消动画时
工具.输出("Cancel")
}



// 开始使用 动画背景
//创建动画背景
//输入是否重复执行
是 dhbj = dh.动画背景(true)

//添加元素
//输入背景图像或图片变量或背景对象，输入显示时长
dhbj.添加("@t1.png", 1000)
dhbj.添加("%t2.png", 1000)
dhbj.添加(资源.图像.t3, 1000)

//设为指定控件背景
视图.图像(资源.编号.tx1).背景(dhbj)

//开始动画
dhbj.开始()

//停止动画
dhbj.停止()

//是否在运行
是 zzyx = dhbj.正在运行()


【字符.json解析 json数据解析】
用法：

//解析json数据
是 text = "{\"id\":1, \"name\":\"xiaobai\", \"age\":16}"
是 jo = 字符.json解析(text)

// 获取根json对象
是 json = jo.json

//获取id
是 id = jo.获取(json, "id")

//获取name
是 name = jo.获取(json, "name")

//获取age
是 age = jo.获取(json, "age")

//修改age数据
jo.设置(json, "age", 20)

//删除id数据
是 sc = jo.删除(json, "id")

//打印json数据
是 text = jo.json(json)



//解析json列表数据
是 text = "{\"userlist\":[{\"id\":1, \"name\":\"niubi\", \"age\":16},{\"id\":2, \"name\":\"wangba\", \"age\":18},{\"id\":3, \"name\":\"goudan\", \"age\":17}]}"
是 jo = 字符.json解析(text)

// 获取根json对象
是 json = jo.json

//获取json对象列表
是 list = jo.对象列表(json, "userlist")
// 获取列表的长度
是 size = jo.长度(list)
循环 size > 0
{
size = size - 1
是 dx = jo.对象(list, size)

//获取id
是 id = jo.获取(dx, "id")

//获取name
是 name = jo.获取(dx, "name")

//获取age
是 age = jo.获取(dx, "age")

}

【utb Toolbar工具栏设置】
用法：

//设置自定义的工具栏 为当前界面的工具栏
//输入Toolbar工具栏的 控件id或控件对象
是 gjl = 视图.工具栏布局(资源.编号.gjlbj1).工具栏()

// 设置左按钮可用
gjl.左按钮可用(true)

// 设置左按钮是否显示
gjl.左按钮显示(true)

// 设置左按钮为小箭头
gjl.左按钮小箭头(true)

// 设置左按钮图像
gjl.左按钮图像("@t1.png")
//gjl.左按钮图像(资源.图像.tp1)

// 设置左按钮监听事件
gjl.左按钮监听事件{
工具.输出("左按钮监听事件")
}

// 设置右按钮图像，无事件。可使用界面菜单事件
gjl.右按钮图像("@t1.png")
//gjl.右按钮图像(资源.图像.tp1)

//显示或隐藏 自定义布局
gjl.显示自定义布局(true)

//显示或隐藏 标题
gjl.显示标题(true)

//获取高度
是 g = gjl.高()

//设置显示选项
gjl.显示选项(2)
//获取显示选项
是 xsxx = gjl.显示选项()


//设置自定义布局
// 新建一个控件
是 wb1 = 视图.文本();
wb1.kg(-1, -2);
gjl.自定义布局(wb1)
//获取自定义布局
是 zdybj = gjl.自定义布局()

//设置标题
gjl.标题("这是标题")
//获取标题
是 bt = gjl.标题()

//设置子标题
gjl.子标题("这是子标题")
//获取子标题
是 bt = gjl.子标题()


【视图.弹窗提醒 弹窗提醒】
用法：
//无按钮弹出提醒
//输入控件对象或ID，输入字符，输入显示时长（值0 -1 -2）
视图.弹窗提醒(资源.编号.xxbj1, "ni hao!", 0)


//有按钮弹出提醒
//输入控件对象可设置null，输入字符，输入显示时长（值0 -1 -2），输入按钮标题
视图.弹窗提醒(资源.编号.xxbj1, "ni hao ma?", 0, "OK")
{
工具.输出("go")
}

//有按钮弹出提醒
//输入控件对象可设置null，输入字符，输入显示时长（值0 -1 -2），输入按钮标题，颜色
视图.弹窗提醒(资源.编号.xxbj1, "ni hao ma?", 0, "OK", "#000000")
{
工具.输出("go")
}


【滑动窗体控制】
用法：

// 获取滑动窗体
是 hdct1 = 视图.滑动窗体(资源.编号.hdct1)

//绑定标签布局，绑定后滑动界面时标签布局会跟随运动，需要注意 标签布局 和 滑动窗体 的子项数量应一致，新增子项时也需要同时增加
//输入标签布局的 控件id或控件对象，是否应刷新其内容
是 bdbqbj = hdct1.绑定标签布局(资源.编号.bqbj1, true)
//注意：如果绑定前 标签布局 如有设置子项，绑定时会被清空。绑定后直接添加滑动窗体 的子项并设置 标题


// 获取标签布局
是 hdct1 = 视图.标签布局(资源.编号.bqbj1)

// 加标签
hdct1.加标签("选项")



// 获取页面管理
是 ym1 = hdct1.页面()


//添加新的页面，设置的界面会执行载入事件里的代码
//输入插入序号 如-1为尾部 0为头部，输入标题，输入界面类，输入布局资源，输入控件ID或数据ID，输入数据内容
是 ids = { 资源.编号.wb1, 资源.编号.wb2, 资源.编号.wb3 }
是 values = { "abc", "bac", "bbc" }
ym1.加(-1, "标题", a.lei, 资源.布局.a, ids, values)


//删除界面
//输入滑动窗体的 控件id或控件对象，输入标识，输入界面序号 序号以0开始 -1为尾部
ym1.删除(0)


//修改界面标题
//输入滑动窗体的 控件id或控件对象，输入标识，输入界面序号 序号以0开始 -1为尾部
ym1.修改(0, "标题2")


//获取页面数量
是 ymsl = ym1.页面数量()

//释放内存
ym1.释放()


// 其中列表的项目所用的布局是界面 a.iyu 上面的布局，并且布局控件可以设置事件。

// 在其事件中获取相关列表适配器数据

// 如 a.iyu界面中 ID 资源.编号.wb1 的控件 的 单击触屏事件 进行 页面数据的操作


// 页面数据的操作
是 lb2 = 数据.列表(vw)

// 获取触发控件的位置
是 lbcfwz = lb2.列表触发位置()

// 获取触发控件的数据对象
是 lbcfsj = lb2.列表触发数据()

// 获取指定ID的对应数据
是 lbcfsj2 = lb2.列表触发数据(资源.编号.wb1)

// 获取指定位置 和 指定ID的对应数据
是 lbsj1 = lb2.列表数据(0, 资源.编号.wb1)

// 获取指定位置数据对象
是 lbsj2 = lb2.列表数据(0)

// 获取列表数据对象
是 lbsj3 = lb2.列表数据()

// 获取项目根视图控件
是 lbxmst = lb2.列表项目视图()


【视图.tccd 弹出菜单】
用法：

// 代码自定义菜单
// 输入菜单绑定的控件对象或ID
是 tccd = 视图.弹出菜单(资源.编号.xxbj1)(mi){

// 触发选择后
是 id = mi.getItemId()
如果 id == 0{
// 选择了 选项1
工具.输出("选项1")

}, id == 1{
// 选择了 选项2
工具.输出("选项2")

}
// 该回调有返回值 为布尔类型；注意一定要设置一个返回值
返回 fou
}
// 获取菜单对象
是 menu = tccd.getMenu()
// 添加菜单
menu.add(0, 0, 0, "选项1")
menu.add(1, 1, 1, "选项2")
// 弹出菜单
tccd.show()


// 使用xml载入菜单
// 输入是否默认弹出菜单，输入菜单绑定的控件对象或ID，输入菜单的XML对应ID
是 tccd = 视图.弹出菜单(true, 资源.编号.xxbj1, zy.menu.caidan)(mi){

// 触发选择后
是 id = mi.getItemId()
如果 id == 0{
// 选择了 选项1
工具.输出("选项1")

}, id == 1{
// 选择了 选项2
工具.输出("选项2")

}
// 该回调有返回值 为布尔类型；注意一定要设置一个返回值
返回 fou
}


// 使用数组创建菜单
是 ids = { 0, 1 }
是 names = { "选项1", "选项2" }

// 输入是否默认弹出菜单，输入菜单绑定的控件对象或ID，输入菜单ID数组，输入菜单标题数组
是 tccd = 视图.弹出菜单(true, 资源.编号.xxbj1, ids, names)(mi){

// 触发选择后
是 id = mi.getItemId()
如果 id == 0{
// 选择了 选项1
工具.输出("选项1")

}, id == 1{
// 选择了 选项2
工具.输出("选项2")

}
// 该回调有返回值 为布尔类型；注意一定要设置一个返回值
返回 fou
}


【动态设置事件】
用法：

// 获取一个编辑框控件对象
是 bjk = 视图.bjk(资源.编号.bjk1)

// 下面以编辑框控件对象为例，动态设置常用监听事件

// ---  动态设置单击触屏事件 --- 
// 简易写法
bjk.事件.单击{
工具.输出("单击")
}
或
bjk.事件.单击(){
工具.输出("单击")
}

// 定义参数
bjk.事件.单击()(vw){
工具.输出("单击，参数一：" + vw)
}

// ---  动态设置触屏监听事件 --- 
bjk.事件.触屏(){
工具.输出("触屏")
// 需要返回一个boolean值
返回 fou
}

// 定义参数
bjk.事件.触屏()(vw,me){
工具.输出("触屏，参数一：" + vw + "  参数二：" + me)
// 需要返回一个boolean值
返回 fou
}

// ---  动态设置触屏长按事件 --- 
bjk.事件.触屏长按(){
工具.输出("触屏长按")
// 需要返回一个boolean值
返回 fou
}

// 定义参数
bjk.事件.触屏长按()(vw){
工具.输出("单击，参数一：" + vw)
// 需要返回一个boolean值
返回 fou
}

// ---  动态设置键盘触发事件 --- 
bjk.事件.键盘触发(){
工具.输出("键盘触发")
// 需要返回一个boolean值
返回 fou
}

// 定义参数
bjk.事件.键盘触发()(vw,kc,et){
工具.输出("键盘触发，参数一：" + vw + "  参数二：" + kc + "  参数三：" + et)
// 需要返回一个boolean值
返回 fou
}

// ---  动态设置获得焦点事件 --- 
bjk.事件.获得焦点(){
工具.输出("获得焦点")
}

// 定义参数
bjk.事件.获得焦点()(vw,hf){
工具.输出("获得焦点，参数一：" + vw + "  参数二：" + hf)
}

// ---  动态设置编辑框监听 --- 
bjk.事件.编辑框监听(){
工具.输出("编辑框监听")
// 需要返回一个boolean值
返回 fou
}

// 定义参数
bjk.事件.编辑框监听()(vw,ad,et){
工具.输出("编辑框监听，参数一：" + vw + "  参数二：" + ad + "  参数三：" + et)
// 需要返回一个boolean值
返回 fou
}

// ---  动态设置文本更新监听事件 --- 
bjk.事件.文本更新(){
工具.输出("文本改变")
}, {
工具.输出("文本改变之前")
}, {
工具.输出("文本改变之后")
}

// 定义参数
bjk.事件.文本更新()(cs,sr,be,ct){
工具.输出("文本改变，参数一：" + cs + "  参数二：" + sr + "  参数三：" + be + "  参数四：" + ct)
}, (cs,sr,ct,ar){
工具.输出("文本改变之前，参数一：" + cs + "  参数二：" + sr + "  参数三：" + ct + "  参数四：" + ar)
}, (ee){
工具.输出("文本改变之后，参数一：" + ee)
}

【自定义控件】
新增控件：在 添加控件 滑动到底部，点击 添加新控件
例，输入：
控件名：线性的控件
完整类名：android.widget.LinearLayout

代码相关操作：
// 根据控件ID 来获取自定义控件对象
android.widget.LinearLayout xxbj = st.st(zy.i.v1)

// 获取到对象后，就可以调用该控件的方法等等操作
xxbj.xxx()
s abc = xxbj.xxx
...



【更多代码正在测试中，会逐步开放！】
